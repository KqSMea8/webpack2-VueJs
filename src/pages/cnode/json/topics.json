{
    "success": true,
    "data": [
        {
            "id": "58d0fb3517f61387400b7e15",
            "author_id": "4f447c2f0a8abae26e01b27d",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/1ac00bee5abd7cc1d9a9435f861acba6.png\" alt=\"screenshot.png\"></p>\n<blockquote>\n<p>原文地址：<a href=\"https://zhuanlan.zhihu.com/p/25860846\">https://zhuanlan.zhihu.com/p/25860846</a></p>\n</blockquote>\n<hr>\n<p>时光如梭，转眼间 Egg.js 已经开源半年了，我们很荣幸地宣布，Egg.js 正式发布 1.0 版本。</p>\n<ul>\n<li>官网传送门：<a href=\"https://eggjs.org\">https://eggjs.org</a></li>\n<li>GitHub：<a href=\"https://github.com/eggjs/egg\">https://github.com/eggjs/egg</a></li>\n<li>Egg.js 英文文档：与 SwiftGG 翻译组强强联合，中译英的小伙伴招募中，如果你有兴趣，请试译 这篇文章 ，并注明你的 qq 号，发送给 SwiftGG 的同学邮箱(<a href=\"mailto:1030041592@qq.com\">1030041592@qq.com</a>)。期待你的加入！</li>\n</ul>\n<h2>特点</h2>\n<ul>\n<li><strong>『企业级的 Node.js Web 基础框架』</strong>，寓意 - 孕育新生。</li>\n<li>业界领先的 <strong>『微内核 + 插件机制』</strong>，专为团队架构师量身打造的 <strong>『框架定制』</strong> 能力。</li>\n<li>内建的安全机制与多进程管理模型。</li>\n<li>高可用，高质量，严格遵循 Semver 规则，测试覆盖率 100%（travis/appveyor)。</li>\n<li>同时支持 koa 1.x 和 2.x 生态，支持 ES 2017 Async Await。</li>\n<li>沉淀自阿里各行各业不同领域最佳实践的插件，涵盖了常见的业务开发场景，稳定支撑了 15 和 16 年天猫双11大促，顶级流量压力。</li>\n<li>渐进式，极具伸缩性，既适合个人小项目快速开发，也适合企业级的团队开发协作。</li>\n</ul>\n<blockquote>\n<p>更详细的特点，以及 Node.js 在阿里的定位，可以参见： <a href=\"https://www.zhihu.com/question/50526101/answer/144952130\">如何评价阿里开源的企业级 Node.js 框架 egg？</a></p>\n</blockquote>\n<h2>里程碑</h2>\n<ul>\n<li>2013 年蚂蚁的 chair 框架，可视为 Egg.js 前身。</li>\n<li>2015 年 11 月，在苏千的召集下，阿里各 BU 的前端骨干齐聚黄龙，闭门共建一周。</li>\n<li>2016 年初，各 BU 的基础 Web 框架完成升级，在同一套规范的基础上进行差异化定制。</li>\n<li>2016 年中，成为阿里 Node.js 基建，广泛使用在绝大部分阿里的前端 Node.js 应用。</li>\n<li>2016 年 09 月，在 <a href=\"http://2016.jsconf.cn/\">JSConf China 2016</a> 上亮相并宣布开源。</li>\n<li>2017 年初，经过一周的<a href=\"https://cnodejs.org/topic/5870e9da04dcf9a706a745f0\">闭关直播写文档</a>，期待已久的 <a href=\"https://eggjs.org/\">官方文档</a> 诚意登场，足足近 30 篇。</li>\n<li>2017年 02 月，知乎问答：<a href=\"https://www.zhihu.com/question/50526101/answer/144952130\">如何评价阿里开源的企业级 Node.js 框架 egg？</a></li>\n<li>2017 年 02 月第 2 周，上了 <strong>GitHub Trending</strong> 周榜第三，Star 数增加 1k 多。</li>\n<li>2017 年 03 月 21 日，Egg.js 正式发布 1.0.0 。</li>\n</ul>\n<h2>成就</h2>\n<ul>\n<li>截止到今天，2250+ Star，50+ 插件，10+ 核心开发者，30+ 贡献者。</li>\n<li>GitHub Trending 周榜第三，并上了 Node Weekly 周刊。</li>\n<li>官网 UV 日均 300+ 。</li>\n</ul>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/2a69766ae55cab517418e7b2f004d9b9.png\" alt=\"screenshot.png\"></p>\n<ul>\n<li>Node TSC Director - Rod Vagg 在 Twitter 上关注并转发。</li>\n</ul>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/42f3483f8c7b9a39678958816f477ae2.png\" alt=\"screenshot.png\"></p>\n<h2>感言</h2>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/6461618ea8944a1fb5ada1db8aeb7de7.png\" alt=\"screenshot.png\"></p>\n<h2>规划</h2>\n<ul>\n<li>Egg.js 英文文档翻译，欢迎加入 <a href=\"http://swift.gg/\">SwiftGG 翻译组</a> 发起的 <a href=\"https://github.com/eggjs/egg/issues/363\">Egg 文档翻译项目</a>。</li>\n<li>继续完善文档，沉淀最佳实践，并帮助社区产出更多的插件和上层框架。</li>\n<li>Node.js 8 LTS 发布后，底层将无缝升级到 Koa<a href=\"/user/2\">@2</a> 。</li>\n</ul>\n</div>",
            "title": "Egg.js 1.0.0 正式发布 - 企业级 Node.js 框架",
            "last_reply_at": "2017-05-26T02:01:12.959Z",
            "good": false,
            "top": true,
            "reply_count": 148,
            "visit_count": 27650,
            "create_at": "2017-03-21T10:06:45.487Z",
            "author": {
                "loginname": "atian25",
                "avatar_url": "https://avatars.githubusercontent.com/u/227713?v=3&s=120"
            }
        },
        {
            "id": "58ad76db7872ea0864fedfcc",
            "author_id": "51f0f267f4963ade0e08f503",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/FlwW5i2h_UuKpnBXXvD3AqyrwjHP\" alt=\"untitled4.png\"></p>\n<h1>饿了么大前端 Node.js 进阶教程</h1>\n<p>因为 2016 年面试了很多做 Node.js 的同学，发现大部分做 Node 的同学都是前端转过来的，对后端的知识大多一片空白。所以很难招到比较好的 Node.js 服务端程序员（注意，不是全栈）。</p>\n<p>于是出于我们一贯的开源与分享精神，我们筹备了这个名字叫《如何通过饿了么 Node.js 面试》的开源的 Node.js 进阶教程。</p>\n<p>github 仓库地址：<a href=\"https://github.com/ElemeFE/node-interview\">https://github.com/ElemeFE/node-interview</a></p>\n<h3>导读</h3>\n<p>本教程包含 2~3 年经验的 Node.js 服务端需要知道的知识点。</p>\n<p>需要注意的是, 并不适用于零基础的同学, 你需要有一定的 JavaScript/Node.js 基础, 并且有一定的工作经验. 另外本教程的重点更准确的说是服务端基础中 Node.js 程序员需要了解的部分.</p>\n<p>稳重将一些常见的问题划分归类, 每类标明涵盖的一些<code>覆盖点</code>, 并且列举几个<code>常见问题</code>, 通常这些问题都是 2~3 年工作经验需要了解或者面对的. 如果你对某类问题感兴趣, 或者想知道其中列举问题的答案, 可以通过该类下方的 <code>阅读更多</code> 查看更多的内容.</p>\n<p>整体上大纲列举的并不是很全面, 细节上覆盖率不高, 很多讨论只是点到即止, 希望大家带着问题去思考.</p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md\">Js 基础问题</a></h2>\n<blockquote>\n<p>与前端 Js 不同, 后端是直面服务器的, 更加偏向内存方面.</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md#%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD\"><code>[Basic]</code> 类型判断</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md#%E4%BD%9C%E7%94%A8%E5%9F%9F\"><code>[Basic]</code> 作用域</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md#%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92\"><code>[Basic]</code> 引用传递</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md#%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE\"><code>[Basic]</code> 内存释放</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md#es6-%E6%96%B0%E7%89%B9%E6%80%A7\"><code>[Basic]</code> ES6 新特性</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>js 中什么类型是引用传递, 什么类型是值传递? 如何将值类型的变量以引用的方式传递? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md#q-value\">[more]</a></li>\n<li>js 中， 0.1 + 0.2 === 0.3 是否为 true ? 在不知道浮点数位数时应该怎样判断两个浮点数之和与第三数是否相等？</li>\n<li>const 定义的 Array 中间元素能否被修改? 如果可以, 那 const 的意义是? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md#q-const\">[more]</a></li>\n<li>JavaScript 中不同类型以及不同环境下变量的内存都是何时释放? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md#q-mem\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/module.md\">模块</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/module.md#%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6\"><code>[Basic]</code> 模块机制</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/module.md#%E7%83%AD%E6%9B%B4%E6%96%B0\"><code>[Basic]</code> 热更新</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/module.md#%E4%B8%8A%E4%B8%8B%E6%96%87\"><code>[Basic]</code> 上下文</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>a.js 和 b.js 两个文件互相 require 是否会死循环? 双方是否能导出变量? 如何从设计上避免这种问题? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/module.md#q-loop\">[more]</a></li>\n<li>如果 a.js require 了 b.js, 那么在 b 中定义全局变量 <code>t = 111</code> 能否在 a 中直接打印出来? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/module.md#q-global\">[more]</a></li>\n<li>如何在不重启 node 进程的情况下热更新一个 js/json 文件? 这个问题本身是否有问题? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/module.md#q-hot\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/module.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md\">事件/异步</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#promise\"><code>[Basic]</code> Promise</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#events\"><code>[Doc]</code> Events (事件)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#timers\"><code>[Doc]</code> Timers (定时器)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#%E9%98%BB%E5%A1%9E%E5%BC%82%E6%AD%A5\"><code>[Point]</code> 阻塞/异步</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#%E5%B9%B6%E8%A1%8C%E5%B9%B6%E5%8F%91\"><code>[Point]</code> 并行/并发</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>Promise 中 .then 的第二参数与 .catch 有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#q-1\">[more]</a></li>\n<li>Eventemitter 的 emit 是同步还是异步? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#q-2\">[more]</a></li>\n<li>如何判断接口是否异步? 是否只要有回调函数就是异步? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#q-3\">[more]</a></li>\n<li>nextTick, setTimeout 以及 setImmediate 三者有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#q-4\">[more]</a></li>\n<li>如何实现一个 sleep 函数? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#q-5\">[more]</a></li>\n<li>如何实现一个异步的 reduce? (注:不是异步完了之后同步 reduce) <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#q-6\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md\">进程</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#process\"><code>[Doc]</code> Process (进程)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#child-process\"><code>[Doc]</code> Child Processes (子进程)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#cluster\"><code>[Doc]</code> Cluster (集群)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1\"><code>[Basic]</code> 进程间通信</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B\"><code>[Basic]</code> 守护进程</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>进程的当前工作目录是什么? 有什么作用? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#q-cwd\">[more]</a></li>\n<li>child_process.fork 与 POSIX 的 fork 有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#q-fork\">[more]</a></li>\n<li>父进程或子进程的死亡是否会影响对方? 什么是孤儿进程? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#q-child\">[more]</a></li>\n<li>cluster 是如何保证负载均衡的? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#how-it-works\">[more]</a></li>\n<li>什么是守护进程? 如何实现守护进程? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md\">IO</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#buffer\"><code>[Doc]</code> Buffer</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#string-decoder\"><code>[Doc]</code> String Decoder (字符串解码)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#stream\"><code>[Doc]</code> Stream (流)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#console\"><code>[Doc]</code> Console (控制台)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#file\"><code>[Doc]</code> File System (文件系统)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#readline\"><code>[Doc]</code> Readline</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#repl\"><code>[Doc]</code> REPL</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>Buffer 一般用于处理什么数据? 其长度能否动态变化? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#buffer\">[more]</a></li>\n<li>Stream 的 highWaterMark 与 drain 事件是什么? 二者之间的关系是? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#%E7%BC%93%E5%86%B2%E5%8C%BA\">[more]</a></li>\n<li>Stream 的 pipe 的作用是? 在 pipe 的过程中数据是引用传递还是拷贝传递? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#pipe\">[more]</a></li>\n<li>什么是文件描述符? 输入流/输出流/错误流是什么? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#file\">[more]</a></li>\n<li>console.log 是同步还是异步? 如何实现一个 console.log? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#console\">[more]</a></li>\n<li>如何同步的获取用户的输入?  <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#%E5%A6%82%E4%BD%95%E5%90%8C%E6%AD%A5%E7%9A%84%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E7%9A%84%E8%BE%93%E5%85%A5\">[more]</a></li>\n<li>Readline 是如何实现的? (有思路即可) <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#readline\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md\">Network</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#net\"><code>[Doc]</code> Net (网络)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#udp\"><code>[Doc]</code> UDP/Datagram</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#http\"><code>[Doc]</code> HTTP</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#dns\"><code>[Doc]</code> DNS (域名服务器)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#zlib\"><code>[Doc]</code> ZLIB (压缩)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#rpc\"><code>[Point]</code> RPC</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>cookie 与 session 的区别? 服务端如何清除 cookie? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#q-cookie-session\">[more]</a></li>\n<li>HTTP 协议中的 POST 和 PUT 有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#q-post-put\">[more]</a></li>\n<li>什么是跨域请求? 如何允许跨域? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#q-cors\">[more]</a></li>\n<li>TCP/UDP 的区别? TCP 粘包是怎么回事，如何处理? UDP 有粘包吗? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#q-tcp-udp\">[more]</a></li>\n<li><code>TIME_WAIT</code> 是什么情况? 出现过多的 <code>TIME_WAIT</code> 可能是什么原因? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#q-time-wait\">[more]</a></li>\n<li>ECONNRESET 是什么错误? 如何复现这个错误?</li>\n<li>socket hang up 是什么意思? 可能在什么情况下出现? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#socket-hang-up\">[more]</a></li>\n<li>hosts 文件是什么? 什么叫 DNS 本地解析?</li>\n<li>列举几个提高网络传输速度的办法?</li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md\">OS</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#tty\"><code>[Doc]</code> TTY</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#os\"><code>[Doc]</code> OS (操作系统)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#path\"><code>[Doc]</code> Path</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0\"><code>[Doc]</code> 命令行参数</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#%E8%B4%9F%E8%BD%BD\"><code>[Basic]</code> 负载</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#checklist\"><code>[Point]</code> CheckList</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>什么是 TTY? 如何判断是否处于 TTY 环境? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#tty\">[more]</a></li>\n<li>不同操作系统的换行符 (EOL) 有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#os\">[more]</a></li>\n<li>服务器负载是什么概念? 如何查看负载? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#%E8%B4%9F%E8%BD%BD\">[more]</a></li>\n<li>ulimit 是用来干什么的? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#ulimit\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md\">错误处理/调试/优化</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#errors\"><code>[Doc]</code> Errors (异常)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#domain\"><code>[Doc]</code> Domain (域)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#debugger\"><code>[Doc]</code> Debugger (调试器)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#c-c++-addon\"><code>[Doc]</code> C/C++ 插件</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#v8\"><code>[Doc]</code> V8</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#%E5%86%85%E5%AD%98%E5%BF%AB%E7%85%A7\"><code>[Point]</code> 内存快照</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#cpu-profiling\"><code>[Point]</code> CPU profiling</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>怎么处理未预料的出错? 用 try/catch ，domains 还是其它什么? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#q-handle-error\">[more]</a></li>\n<li>什么是 <code>uncaughtException</code> 事件? 一般在什么情况下使用该事件? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#uncaughtexception\">[more]</a></li>\n<li>domain 的原理是? 为什么要弃用 domain? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#domain\">[more]</a></li>\n<li>什么是防御性编程? 与其相对的 let it crash 又是什么?</li>\n<li>为什么要在 cb 的第一参数传 error? 为什么有的 cb 第一个参数不是 error, 例如 http.createServer?</li>\n<li>为什么有些异常没法根据报错信息定位到代码调用? 如何准确的定位一个异常? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#%E9%94%99%E8%AF%AF%E6%A0%88%E4%B8%A2%E5%A4%B1\">[more]</a></li>\n<li>内存泄漏通常由哪些原因导致? 如何分析以及定位内存泄漏? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#%E5%86%85%E5%AD%98%E5%BF%AB%E7%85%A7\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md\">测试</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95\"><code>[Basic]</code> 测试方法</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95\"><code>[Basic]</code> 单元测试</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95\"><code>[Basic]</code> 集成测试</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95\"><code>[Basic]</code> 基准测试</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95\"><code>[Basic]</code> 压力测试</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#assert\"><code>[Doc]</code> Assert (断言)</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>为什么要写测试? 写测试是否会拖累开发进度?<a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#q-why-write-test\">[more]</a></li>\n<li>单元测试的单元是指什么? 什么是覆盖率?<a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95\">[more]</a></li>\n<li>测试是如何保证业务逻辑中不会出现死循环的?<a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#q-death-loop\">[more]</a></li>\n<li>mock 是什么? 一般在什么情况下 mock?<a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#mock\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md\">util</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md#url\"><code>[Doc]</code> URL</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md#query-strings\"><code>[Doc]</code> Query Strings (查询字符串)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md#util-1\"><code>[Doc]</code> Utilities (实用函数)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><code>[Basic]</code> 正则表达式</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>HTTP 如何通过 GET 方法 (URL) 传递 let arr = [1,2,3,4] 给服务器? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md#get-param\">[more]</a></li>\n<li>Node.js 中继承 (util.inherits) 的实现? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md#utilinherits\">[more]</a></li>\n<li>如何递归获取某个文件夹下所有的文件名? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md#q-traversal\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md\">存储</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#mysql\"><code>[Point]</code> Mysql</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#mongodb\"><code>[Point]</code> Mongodb</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#replication\"><code>[Point]</code> Replication</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7\"><code>[Point]</code> 数据一致性</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#%E7%BC%93%E5%AD%98\"><code>[Point]</code> 缓存</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>备份数据库与 M/S, M/M 等部署方式的区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#replication\">[more]</a></li>\n<li>索引有什么用，大致原理是什么? 设计索引有什么注意点? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#%E7%B4%A2%E5%BC%95\">[more]</a></li>\n<li>Monogdb 连接问题(超时/断开等)有可能是什么问题导致的? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#Mongodb\">[more]</a></li>\n<li>什么情况下数据会出现脏数据? 如何避免? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7\">[more]</a></li>\n<li>redis 与 memcached 的区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#%E7%BC%93%E5%AD%98\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md\">安全</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#crypto\"><code>[Doc]</code> Crypto (加密)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#tlsssl\"><code>[Doc]</code> TLS/SSL</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#https\"><code>[Doc]</code> HTTPS</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#xss\"><code>[Point]</code> XSS</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#csrf\"><code>[Point]</code> CSRF</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB\"><code>[Point]</code> 中间人攻击</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#sqlnosql-%E6%B3%A8%E5%85%A5\"><code>[Point]</code> Sql/Nosql 注入</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>加密是如何保证用户密码的安全性? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#crypto\">[more]</a></li>\n<li>TLS 与 SSL 有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#tlsssl\">[more]</a></li>\n<li>HTTPS 能否被劫持? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#https\">[more]</a></li>\n<li>XSS 攻击是什么? 有什么危害? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#xss\">[more]</a></li>\n<li>过滤 Html 标签能否防止 XSS? 请列举不能的情况? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#xss\">[more]</a></li>\n<li>CSRF 是什么? 如何防范? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#csrf\">[more]</a></li>\n<li>如何避免中间人攻击? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md\">阅读更多</a></p>\n<h2>最后</h2>\n<p>目前 repo 处于施工现场的情况，如果发现问题欢迎在 <a href=\"https://github.com/ElemeFE/node-interview/issues\">issues</a> 中指出。如果有比较好的<code>问题/知识点/指正</code>，也欢迎提 PR。</p>\n<p>另外关于 <code>Js 基础</code> 是个比较大的话题，在本教程不会很细致深入的讨论，更多的是列出一些重要或者更服务端更相关的地方，所以如果你拿着《JavaScript 权威指南》给教程提 PR 可能不会采纳。本教程的重点更准确的说是服务端基础中 Node.js 程序员需要了解的部分。</p>\n</div>",
            "title": "饿了么大前端 Node.js 进阶教程",
            "last_reply_at": "2017-05-26T01:36:41.875Z",
            "good": true,
            "top": true,
            "reply_count": 145,
            "visit_count": 49439,
            "create_at": "2017-02-22T11:32:43.547Z",
            "author": {
                "loginname": "lellansin",
                "avatar_url": "https://avatars1.githubusercontent.com/u/2081487?v=3&s=120"
            }
        },
        {
            "id": "58e607b0ddee72813eb22323",
            "author_id": "4efc278525fa69ac6900000f",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p><a href=\"https://github.com/cnpm/cnpm\">cnpm cli</a> 的 install 速度已经是目前最快的一种 npm installer 了，最近 npm registry 推出了一种全新的 registry api 格式: <a href=\"https://github.com/npm/registry/blob/master/docs/responses/package-metadata.md#abbreviated-metadata-format\">Abbreviated metadata format</a>，它可以大大减少install 过程中的网络请求数据大小，于是我们也在第一时间实现到 npminstall 中了。</p>\n<p>为了更加平滑地更新过渡，我们计划使用2周时间来做beta测试，然后没什么大问题之后，将会发布正式版本的 cnpm<a href=\"/user/5\">@5</a> 。</p>\n<h2>尝鲜者来</h2>\n<p>直接通过 beta 版本可以参与测试。</p>\n<pre class=\"prettyprint language-bash\"><code>$ cnpm install cnpm@beta -g \n</code></pre><h2>问题反馈</h2>\n<p>遇到任何问题，请直接回复到 <a href=\"https://github.com/cnpm/cnpm/pull/187\">https://github.com/cnpm/cnpm/pull/187</a> 。</p>\n<h2>回滚</h2>\n<p>一键回滚到稳定版本。</p>\n<pre class=\"prettyprint language-bash\"><code>$ cnpm install cnpm -g\n</code></pre></div>",
            "title": "cnpm@5 beta 测试招募",
            "last_reply_at": "2017-05-25T17:10:23.639Z",
            "good": false,
            "top": true,
            "reply_count": 136,
            "visit_count": 17570,
            "create_at": "2017-04-06T09:17:36.511Z",
            "author": {
                "loginname": "fengmk2",
                "avatar_url": "https://avatars3.githubusercontent.com/u/156269?v=3&s=120"
            }
        },
        {
            "id": "58eee565a92d341e48cfe7fc",
            "author_id": "54009f5ccd66f2eb37190485",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><h1>2017，我们来聊聊 Node.js</h1>\n<h2>版本帝？</h2>\n<p>Chrome浏览器已经蹦到57版本了，是名副其实的版本帝，作为兄弟的Node.js也一样，1.0之前等了6年，而从1.0到8.0，只用了2年时间，这世界到底怎么了？</p>\n<p>我们就数一下</p>\n<ul>\n<li>从v0.1到0.12用了6年</li>\n<li>2015-01-14发布了v1.0.0版本（io.js）</li>\n<li>2.x（io.js）</li>\n<li>3.x（io.js）</li>\n<li>2015年09月Node.js基金会已发布Node.js V4.0版 与io.js合并后的第一个版本</li>\n<li>2015年10月Node.jsv4.2.0将是首个lts长期支持版本</li>\n<li>2016年底发布到4.2.4 &amp;&amp; 5.4.0</li>\n<li>2016年3月20日v4.4.0 LTS（长期支持版本）和v5.9.0 Stable（稳定版本）</li>\n<li>2016 年底 v6.0 支持95%以上的es6特性 ， v7.0通过flag支持async函数，99%的es6特性</li>\n<li>2017年2月发布v7.6版本，可以不通过flag使用async函数</li>\n</ul>\n<p><img src=\"//dn-cnode.qbox.me/Fv8fvViUeOJpBlOWYzBo1txRUhdN\" alt=\"lts-schedule.png\"></p>\n<p>整体来说趋于稳定</p>\n<ul>\n<li>成立了Node.js基金会，能够让Node.js在未来有更好的开源社区支持</li>\n<li>发布了LTS版本，意味着api稳定</li>\n<li>快速发版本，很多人吐槽这个，其实换个角度看，这也是社区活跃的一个体现，但如果大家真的看CHANGELOG，其实都是小改进，而且是边边角角的改进，也就是说Node.js的core（核心）已经非常稳定了，可以大规模使用</li>\n</ul>\n<h2>已无性能优势？</h2>\n<p>Node.js在2009年横空出世，可以说是纯异步获得高性能的功劳。所有语言几乎没有能够和它相比的，比如Java、PHP、Ruby都被啪啪的打脸。但是山一程，水一程，福祸相依，因为性能太出众，导致很多语言、编程模型上有更多探索，比如go语言产生、php里的swolo和vm改进等，大家似乎都以不支持异步为耻辱。后来的故事大家都知道了，性能都提到非常高，c10问题已经没人再考虑，只是大家实现早晚而产生的性能差距而已。</p>\n<blockquote>\n<p>编程语言的性能趋于一样的极限，所以剩下的选择，只有喜好</p>\n</blockquote>\n<p>那么在这种情况下，Node.js还有优势么？</p>\n<ul>\n<li>实现成本：Node.js除了异步流程控制稍复杂外，其他的都非常简单，比如写法，你可以面向过程、面向对象、函数式，根据自己的解决选择就好了。不要因为它现在变化快，就觉得自己跟不上潮流。尤其是后端程序员转Node.js几乎是2周以内的成本，某些语言光熟悉语法习惯也不止2周吧？</li>\n<li>调优成本：Node.js即使不优化，它的性能也非常好，如果优化，也比其他语言更简单</li>\n<li>学习成本：是否必须用，如果是必须要用，那就少学一样是一样，人生有限，不能都花在写hello world上。我想问，大前端离得开js么？</li>\n</ul>\n<blockquote>\n<p>误读：Node.js已无性能优势，它现在最强大的是基于npm的生态</p>\n</blockquote>\n<p>上面是成本上的比较，其实大家把关注点都转移到基于npm的生态上，截止2017年2月，在npm上有超过45万个模块，秒杀无数。npm是所有的开源的包管理里最强大的，我们说更了不起的Node.js，其实npm居功甚伟，后面会有独立的章节进行阐述。</p>\n<p>来自<a href=\"http://www.modulecounts.com/\">www.modulecounts.com</a>的各个包管理模块梳理的比较</p>\n<p><img src=\"//dn-cnode.qbox.me/FjmazMxffKETUdl9-NVoSqLB-DyT\" alt=\"Screen Shot 2017-04-04 at 21.02.41.png\">\nnpm生态是Node的优势不假，可是说“Node.js没有性能优势”真的对么？这其实就是误读，Node.js的性能依然很好呀，而且它有npm极其强大的生态，可谓性能与生态双剑合璧，你说你死不死？</p>\n<h2>异步和回调地狱？</h2>\n<blockquote>\n<p>天生异步，败也异步，成也异步</p>\n</blockquote>\n<p>正因为异步导致了api设计方式只能采用error-first风格的回调，于是大家硬生生的把callback写成了callback hell。于是各种黑粉就冒出来，无非是一些浅尝辄止之辈。但也正因为回调地狱是最差实践，所以大家才不得不求变，于是thunk、promise等纷沓而至。虽然Promise/A+不完美，但对于解决回调地狱是足够的了。而且随着ES6等规范实现，引入generator、co等，让异步越来越近于同步。当async函数落地的时候，Node已经站在了同C#、Python一样的高度上，大家还有什么理由黑呢？</p>\n<p>本小节先科普一下异步流程里的各种概念，后面会有独立章节进行详细讲解</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>说明</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>callback</td>\n<td>Node.js API天生就是这样的</td>\n<td></td>\n</tr>\n<tr>\n<td>thunk</td>\n<td>参数的求值策略</td>\n<td></td>\n</tr>\n<tr>\n<td>promise</td>\n<td>最开始是Promise/A+规范，随后成为ES6标准</td>\n<td></td>\n</tr>\n<tr>\n<td>generator</td>\n<td>ES6种的生成器，用于计算，但tj想用做流程控制</td>\n<td></td>\n</tr>\n<tr>\n<td>co</td>\n<td>generator用起来非常麻烦，故而tj写了co这个generator生成器，用法更简单</td>\n<td></td>\n</tr>\n<tr>\n<td>async函数</td>\n<td>原本计划进入es7规范，结果差一点，但好在v8实现了，所以node 7就可以使用，无须等es7规范落地</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>有时，将一件事儿做到极致，也许能有另一种天地</p>\n</blockquote>\n<h2>应用场景</h2>\n<p>MEAN是一个Javascript平台的现代Web开发框架总称，它是MongoDB + Express +AngularJS + NodeJS 四个框架的第一个字母组合。它与传统LAMP一样是一种全套开发工具的简称。在2014和2015年喜欢讲这个，并且还有MEAN.js等框架，但今天已经过时，Node.js有了更多的应用场景。</p>\n<p>《Node.js in action》一书里说，Node所针对的应用程序有一个专门的简称：DIRT。它表示数据密集型实时（data-intensive real-time）程序。因为Node自身在I/O上非常轻量，它善于将数据从一个管道混排或代理到另一个管道上，这能在处理大量请求时持有很多开放的连接，并且只占用一小部分内存。它的设计目标是保证响应能力，跟浏览器一样。</p>\n<p>这话不假，但在今天来看，DIRT还是范围小了。其实DIRT本质上说的I/O处理的都算，但随着大前端的发展，Node.js已经不再只是I/O处理相关，而是更加的“Node”！</p>\n<p>这里给出Node.js的若干使用场景</p>\n<ul>\n<li>网站（如express/koa等）</li>\n<li>im即时聊天(<a href=\"http://socket.io\">socket.io</a>)</li>\n<li>api（移动端，pc，h5）</li>\n<li>HTTP Proxy（淘宝、Qunar、腾讯、百度都有）</li>\n<li>前端构建工具(grunt/gulp/bower/webpack/fis3…)</li>\n<li>写操作系统（NodeOS）</li>\n<li>跨平台打包工具（PC端的electron、nw.js，比如钉钉PC客户端、微信小程序IDE、微信客户端，移动的cordova，即老的Phonegap，还有更加有名的一站式开发框架ionicframework）</li>\n<li>命令行工具（比如cordova、shell.js）</li>\n<li>反向代理（比如anyproxy，node-http-proxy）</li>\n<li>编辑器Atom、VSCode等</li>\n</ul>\n<p>可以说目前大家能够看到的、用到的软件都有Node.js身影，当下最流行的软件写法也大都是基于Node.js的，比如PC客户端<a href=\"https://github.com/luin/medis\">luin/medis</a>采用electron打包，写法采用React+Redux。我自己一直的实践的【Node全栈】，也正是基于这种趋势而形成的。在未来，Node.js的应用场景会更加的广泛。更多参见<a href=\"https://github.com/sindresorhus/awesome-nodejs\">sindresorhus/awesome-nodejs</a>。</p>\n<h3>Web框架</h3>\n<p>演进时间线大致如下：</p>\n<ul>\n<li>2010年tj写的Express</li>\n<li>2011年Derby.js开始开发，8月5日，WalmartLabs的一位成员Eran Hammer提交了Hapi的第一次commit。Hapi原本是Postmile的一部分，并且最开始是基于Express构建的。后来它发展成自己自己的框架，</li>\n<li>2012年1月21日，专注于rest api的restify发布1.0版本，同构的meteor开始投入开发，最像rails的sails也开始了开发</li>\n<li>2013年tj开始玩generator，编写co这个generator执行器，并开始了Koa。2013 年下半年李成银开始ThinkJS，参考ThinkPHP</li>\n<li>2014年，4月9日，express发布4.0，进入4.x时代持续到今天，MEAN.js开始随着MEAN架构的提出开始开发，意图大一统，另外total.js开始，最像PHP’s Laravel 或 Python’s Django 或 <a href=\"http://ASP.NET\">ASP.NET</a> MVC的框架</li>\n<li>2015年8月22日， 下一代Web框架Koa发布1.0，可以在node 0.12下面，通过co + generator实现同步逻辑，那时候co还是基于thunkfy的，2015.10.30 ThinkJS发布了Es2015+ 特性开发的v 2.0版本</li>\n<li>2016 年 09 月，蚂蚁金服的eggjs，在 JSConf China 2016 上亮相并宣布开源</li>\n<li>2017年2月，下一代Web框架Koa发布2.0</li>\n</ul>\n<p>我们可以根据框架的特性进行分类</p>\n<table>\n<thead>\n<tr>\n<th>框架名称</th>\n<th>特性</th>\n<th>点评</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Express</td>\n<td>简单、实用，路由中间件等五脏俱全</td>\n<td>最著名的Web框架</td>\n</tr>\n<tr>\n<td>Derby.js &amp;&amp; Meteor</td>\n<td>同构</td>\n<td>前后端都放到一起，模糊了开发便捷，看上去更简单，实际上上对开发来说要求更高</td>\n</tr>\n<tr>\n<td>Sails、Total</td>\n<td>面向其他语言，Ruby、PHP等</td>\n<td>借鉴业界优秀实现，也是Node.js成熟的一个标志</td>\n</tr>\n<tr>\n<td>MEAN.js</td>\n<td>面向架构</td>\n<td>类似于脚手架，又期望同构，结果只是蹭了热点</td>\n</tr>\n<tr>\n<td>Hapi和Restfy</td>\n<td>面向Api &amp;&amp; 微服务</td>\n<td>移动互联网时代Api的作用被放大，故而独立分类。尤其是对于微服务开发更是利器</td>\n</tr>\n<tr>\n<td>ThinkJS</td>\n<td>面向新特性</td>\n<td>借鉴ThinkPHP，并慢慢走出自己的一条路，对于Async函数等新特性支持，无出其右</td>\n</tr>\n<tr>\n<td>Koa</td>\n<td>专注于异步流程改进</td>\n<td>下一代Web框架</td>\n</tr>\n</tbody>\n</table>\n<p>对于框架选型</p>\n<ul>\n<li>业务场景、特点，不必为了什么而什么，避免本末倒置</li>\n<li>自身团队能力、喜好，有时候技术选型决定团队氛围的，需要平衡激进与稳定</li>\n<li>出现问题的时候，有人能Cover的住，Node.js虽然8年历史，但模块完善程度良莠不齐，如果不慎踩到一个坑里，需要团队在无外力的情况能够搞定，否则会影响进度</li>\n</ul>\n<blockquote>\n<p>个人学习求新，企业架构求稳，无非喜好与场景而已</p>\n</blockquote>\n<p>我猜大家能够想到的场景，大约如下</p>\n<ul>\n<li>前端工具，比如gulp、grunt、webpack等</li>\n<li>服务器，做类似于Java、PHP的事儿</li>\n</ul>\n<p>如果只是做这些，和Java、PHP等就没啥区别了。如果再冠上更了不起的Node.js，就有点名不符实了。所以这里我稍加整理，看看和大家想的是否一样</p>\n<h3>技术栈演进</h3>\n<p>自从ES 2015（俗称ES 6）在Node.js 落地之后，整个Node.js开发都发生了翻天覆地的变化。自从0.10开始，Node.js就逐渐的加入了ES 6特性，比如0.12就可以使用generator，才导致寻求异步流程控制的tj写出了co这个著名的模块，继而诞生了Koa框架。但是在4.0之前，一直都是要通过flag才能开启generator支持，故而Koa 1.0迟迟未发布，在Node 4.0发布才发布的Koa 1.0。</p>\n<blockquote>\n<p>2015年，成熟的传统，而2016年，变革开始</p>\n</blockquote>\n<p>核心变更：es语法支持</p>\n<ul>\n<li>使用Node.js 4.x或5.x里的es6特性，如果想玩更高级的，可以使用<a href>babel</a>编译支持es7特性，或者typescript</li>\n<li>合理使用<a href=\"https://github.com/feross/standard\">standard</a>  或者 xo 代码风格约定</li>\n<li>适当的引入ES 6语法，只要Node.js SDK支持的，都可以使用</li>\n<li>需要大家重视OO（面向对象）写法的学习和使用，虽然ES 6的OO机制不健全，但这是大方向，以后会一直增强。OO对于大型软件开发更好。这其实也是我看好typescript的原因。</li>\n</ul>\n<p>对比一下变革前后的技术栈选型，希望读者能够从中感受到其中的变化</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>2015年</th>\n<th>2016年</th>\n<th>选型原因</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Web框架</td>\n<td>express 4.x</td>\n<td>koa 1.0 &amp;&amp; 2.0 （koa2.0刚发布不久，喜欢折腾的可以考虑）</td>\n<td>主要在流程控制上的便利，异步毕竟要时刻注意，心累</td>\n</tr>\n<tr>\n<td>数据库</td>\n<td>mongoose（mongodb）</td>\n<td>mongoose（mongodb）</td>\n<td>对mongodb和mysql支持都一样，不过是mongodb更简单，足以应付绝大部分场景</td>\n</tr>\n<tr>\n<td>异步流程控制</td>\n<td>bluebird（Promise/A+实现）</td>\n<td>bluebird（Promise/A+实现）1） Koa 1.0 使用co + generator 2） Koa 2.0 使用async函数</td>\n<td>流程控制演进路线，从promise到async函数，无论如何，promise都是基石，必要掌握的</td>\n</tr>\n<tr>\n<td>模板引擎（视图层）</td>\n<td>ejs &amp;&amp; jade</td>\n<td>jade &amp;&amp; nunjucks</td>\n<td>给出了2种，一种可读性好，另一种简洁高效，都是非常好的</td>\n</tr>\n<tr>\n<td>测试</td>\n<td>mocha</td>\n<td>ava</td>\n<td>mocha是Node.js里著名的测试框架，但对新特性的支持没有ava那么好，而ava基于babel安装也要大上好多</td>\n</tr>\n<tr>\n<td>调试</td>\n<td>node-inspector</td>\n<td>VSCode</td>\n<td>在Node 6和7出来之后，node-inspector支持的不是那么好，相反VSCode可视化，简单，文件多时也不卡，特别好用</td>\n</tr>\n</tbody>\n</table>\n<h3>预处理器</h3>\n<p>前端预处理可分3种</p>\n<ul>\n<li>模板引擎</li>\n<li>css预处理器</li>\n<li>js友好语言</li>\n</ul>\n<p>这些都离不开Node.js的支持，对于前端工程师来说，使用Node.js来实现这些是最方便不过的。</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>实现</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>模板引擎</td>\n<td>art\\mustache\\ejs\\hbs\\jade …</td>\n<td>上百种之多，自定义默认，编译成html，继而完成更多操作</td>\n</tr>\n<tr>\n<td>css预处理器</td>\n<td>less\\sass\\scss\\rework\\postcss</td>\n<td>自定义语法规则，编译成css</td>\n</tr>\n<tr>\n<td>js友好语言</td>\n<td>coffeescript、typescript</td>\n<td>自定义语法规则、编译成js</td>\n</tr>\n</tbody>\n</table>\n<h3>跨平台</h3>\n<p>跨平台指的是PC端、移动端、Web/H5</p>\n<table>\n<thead>\n<tr>\n<th>平台</th>\n<th>实现</th>\n<th>点评</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Web/H5</td>\n<td>纯前端</td>\n<td>不必解释</td>\n</tr>\n<tr>\n<td>PC客户端</td>\n<td>nw.js和electron</td>\n<td>尤其是atom和vscode编辑器最为著名，像钉钉PC端，微信客户端、微信小程序IDE等都是这样的，通过web技术来打包成PC客户端</td>\n</tr>\n<tr>\n<td>移动端</td>\n<td>cordova（旧称PhoneGap），基于cordova的ionicframework</td>\n<td>这种采用h5开发，打包成ipa或apk的应用，称为Hybrid开发（混搭），通过webview实现所谓的跨平台，应用的还是非常广泛的</td>\n</tr>\n</tbody>\n</table>\n<h3>构建工具</h3>\n<p>说起构建工具，大概会想到make、ant、rake、gradle等，其实Node.js里有更多实现</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>介绍</th>\n<th>点评</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>jake</td>\n<td>基于coffeescript的大概都熟悉这个，和make、rake类似</td>\n<td>经典传统</td>\n</tr>\n<tr>\n<td>grunt</td>\n<td>dsl风格的早期著名框架</td>\n<td>配置非常麻烦</td>\n</tr>\n<tr>\n<td>gulp</td>\n<td>流式构建，不会产生中间文件，利用Stream机制，处理大文件和内存有优势，配置简单，只有懂点js就能搞定</td>\n<td>grunt的替代品</td>\n</tr>\n<tr>\n<td>webpack + npm scripts</td>\n<td>说是构建工具有点过，但二者组合勉强算吧，loader和plugin机制还是非常强大的</td>\n<td>流行而已</td>\n</tr>\n</tbody>\n</table>\n<p>构建工具都不会特别复杂，所以Node.js世界里有非常多的实现，还有人写过node版本的make呢，玩的很嗨</p>\n<h3>HTTP Proxy</h3>\n<ul>\n<li>请求代理</li>\n<li>SSR &amp;&amp; PWA</li>\n<li>Api Proxy</li>\n</ul>\n<p>1）请求代理</p>\n<p>对于http请求复杂定制的时候，你是需要让Node.js来帮你的，比如为了兼容一个历史遗留需求，在访问某个CSS的时候必须提供HEADER才可以，如果放到静态server或cdn上是做不到的。</p>\n<p>2）SSR &amp;&amp; PWA</p>\n<p>SSR是服务器端渲染，PWA是渐进式Web应用，都是今年最火的技术。如果大家用过，一定对Node.js不陌生。比如React、Vuejs都是Node.js实现的ssr。至于pwa的service-worker也是Node.js实现的。那么为啥不用其他语言实现呢？不是其他语言不能实现，而是使用Node.js简单、方便、学习成本低，轻松获得高性能，如果用其他语言，我至少还得装环境</p>\n<p>3）Api Proxy</p>\n<p>产品需要应变，后端不好变，一变就要设计到数据库、存储等，可能引发事故。而在前端相对更容易，前端只负责组装服务，而非真正对数据库进行变动，所以只要服务api粒度合适，在前端来处理是更好的。</p>\n<p>Api的问题</p>\n<ul>\n<li>一个页面的Api非常多</li>\n<li>跨域，Api转发</li>\n<li>Api返回的数据对前端不友好，后端讨厌（应付）前端，几种api都懒得根据ui/ue去定制，能偷懒就偷懒</li>\n<li>需求决定Api，Api不一定给的及时</li>\n</ul>\n<p>所以，在前端渲染之余，加一层Api Proxy是非常必要的。淘宝早起曾公开过一张架构图，在今天看来，依然不过时</p>\n<p><img src=\"//dn-cnode.qbox.me/Fr8cGvus0i58atULAnoe-Cv4nu5m\" alt=\"taobao.jpg\"></p>\n<ul>\n<li>左侧半边，浏览器和Node.js Server通信可以有多种协议，HTML、RESTfull、BigPipe、Comet、Socket等，已经足够我们完成任何想做的事儿了</li>\n<li>右侧半边，是Node.js实现的WebServer，Node服务分了2个部分\n<ul>\n<li>常规的Http服务，即大块部分二</li>\n<li>ModelProxy指的是根据Server端的服务，组成并转化成自身的Model层。磨蹭用于为Http服务提供更好的接口</li>\n</ul>\n</li>\n</ul>\n<p>这里的Model Proxy其实就是我们所说的Api Proxy，这张图里只是说了结果，把聚合的服务转成模型，继而为HTTP服务提供Api。</p>\n<p>下面我们再深化一下Api Proxy的概念</p>\n<p><img src=\"//dn-cnode.qbox.me/FpAZo4aPQysJyciBvzUCU9uxb-vf\" alt=\"proxy.png\"></p>\n<p>这里的Node Proxy做了2件事儿，Api和渲染辅助。</p>\n<ul>\n<li>前端的异步ajax请求，可以直接访问Api</li>\n<li>如果是直接渲染或者bigpipe等协议的，需要在服务器端组装api，然后再返回给浏览器。</li>\n</ul>\n<p>所以Api后面还有一个服务组装，在微服务架构流行的今天，这种服务组装放到Node Proxy里的好处尤其明显。既可以提高前端开发效率，又可以让后端更加专注于服务开发。甚至如果前端团队足够大，可以在前端建一个Api小组，专门做服务集成的事儿。</p>\n<h3>Api服务</h3>\n<p>说完了Proxy，我们再看看利益问题。Node.js向后端延伸，必然会触动后端开发的利益。那么Proxy层的事儿，前后端矛盾的交界处，后端不想变，前端又求变，那么长此以往，Api接口会变得越来越恶心。后端是愿意把Api的事儿叫前端的，对后端来说，只要你不动我的数据库和服务就可以。</p>\n<p>但是Node.js能不能做这部分呢？答案是能的 ，这个是和Java、PHP类似的，一般是和数据库连接到一起，处理带有业务逻辑的。目前国内大部分都是以Java、PHP等为主，所以要想吃到这部分并不容易。</p>\n<ul>\n<li>小公司，创业公司，新孵化的项目更倾向于Node.js，简单，快速，高效</li>\n<li>微服务架构下的某些服务，使用Node.js开发，是比较合理的</li>\n</ul>\n<p>国内这部分一直没有做的很好，所以Node.js在大公司还没有很好的被应用，安全问题、生态问题、历史遗留问题等，还有很多人对Node.js的误解</p>\n<ul>\n<li>单线程很脆弱，这是事实，但单线程不等于不能多核并发，而且你还有集群呢</li>\n<li>运维，其实很简单，比其他语言之简单，日志采集、监控也非常简单</li>\n<li>模块稳定性，对于Mongodb、MySQL、Redis等还是相当不错，但其他的数据库支持可能没那么好。</li>\n<li>安全问题，</li>\n</ul>\n<p>这些对于提供Api服务来说已经足够了。</p>\n<h3>其他</h3>\n<table>\n<thead>\n<tr>\n<th>用途</th>\n<th>说明</th>\n<th>前景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>爬虫</td>\n<td>抢了不少Python的份额，整体来说简单，实用</td>\n<td>看涨</td>\n</tr>\n<tr>\n<td>命令行工具</td>\n<td>写工具、提高效率，node+npm真是无出其右</td>\n<td>看涨</td>\n</tr>\n<tr>\n<td>微服务与RPC</td>\n<td>Node做纯后端不好做，但在新项目和微服务架构下，必有一席之地</td>\n<td>看涨</td>\n</tr>\n<tr>\n<td>微信公众号开发</td>\n<td>已经火了2年多了，尤其是付费阅读领域，还会继续火下去，gitchat就是实用Node.js做的，而且还在招人</td>\n<td>看涨</td>\n</tr>\n<tr>\n<td>反向代理</td>\n<td>Node.js可以作为nginx这样的反向代理，虽然线上我们很少这样做，但它确确实实可以这样做。比如node-http-proxy和anyproxy等，其实使用Node.js做这种请求转发是非常简单的</td>\n<td>看涨</td>\n</tr>\n</tbody>\n</table>\n<h2>更好的写法</h2>\n<h3>Async函数与Promise</h3>\n<ul>\n<li>Async函数是趋势，Chrome 52. v8 5.1已经支持Async函数(<a href=\"https://github.com/nodejs/CTC/issues/7\">https://github.com/nodejs/CTC/issues/7</a>)了，Node.js 7.0+支持还会远么？</li>\n<li>Async和Generator函数里都支持promise，所以promise是必须会的。</li>\n<li>Generator和yield异常强大，不过不会成为主流，所以学会基本用法和promise就好了，没必要所有的都必须会。</li>\n<li>co作为Generator执行器是不错的，它更好的是当做Promise 包装器，通过Generator支持yieldable，最后返回Promise，是不是有点无耻？</li>\n</ul>\n<p>我整理了一张图，更直观一些。</p>\n<p><img src=\"//dn-cnode.qbox.me/FkcPwxdGHSCHFvA2nU0ub0zYNRt4\" alt=\"async-all.png\"></p>\n<ul>\n<li>红色代表Promise，是使用最多的，无论async还是generator都可用</li>\n<li>蓝色是Generator，过度货</li>\n<li>绿色是Async函数，趋势</li>\n</ul>\n<p><strong>结论</strong>：Promise是必须会的，那你为什么不顺势而为呢？</p>\n<p><strong>推荐</strong>：使用Async函数 + Promise组合，如下图所示。</p>\n<p><img src=\"//dn-cnode.qbox.me/FhVQF1FKB6sNkoFTc3gU-SVnkGtm\" alt=\"async-suggest.png\"></p>\n<p><strong>实践</strong></p>\n<p>合理的结合Promise和Async函数是可以非常高效的，但也要因场景而异</p>\n<ul>\n<li>Promise更容易做promisefyAll（比如使用bluebird）</li>\n<li>Async函数无法批量操作</li>\n</ul>\n<p>那么，在常见的Web应用里，我们总结的实践是，dao层使用Promise比较好，而service层，使用Async/Await更好。</p>\n<p>dao层使用Promise：</p>\n<ul>\n<li>crud</li>\n<li>单一模型的方法多</li>\n<li>库自身支持Promise</li>\n</ul>\n<p>这种用promisefyAll基本几行代码就够了，一般单一模型的操作，不会特别复杂，应变的需求基本不大。</p>\n<p>而service层一般是多个Model组合操作，多模型操作就可以拆分成多个小的操作，然后使用Await来组合，看起来会更加清晰，另外对需求应变也是非常容易的。</p>\n<h3>ES.next</h3>\n<blockquote>\n<p>Node.js + ES.next = ♥</p>\n</blockquote>\n<h3>Flow &amp;&amp; TypeScript</h3>\n<blockquote>\n<p>Type Systems Will Make You a Better JavaScript Developer</p>\n</blockquote>\n<h3>ES6模块</h3>\n<p>现在ES6自带了模块标准， 也是JS第一次支持module（之前的CommonJS、AMD、CMD都不算）， 但目前的所有Node.js版本都没有支持，目前只能用用Traceur、BabelJS， 或者TypeScript把ES6代码转化为兼容ES5版本的js代码，ES6模块新特性非常吸引人，下面简要说明。</p>\n<p>ES6 模块的目标是创建一个同时兼容CommonJS和AMD的格式，语法更加紧凑，通过编译时加载，使得编译时就能确定模块的依赖关系，效率要比 CommonJS 模块的加载方式高。而对于异步加载和配置模块加载方面，则借鉴AMD规范，其效率、灵活程度都远远好于CommonJS写法。</p>\n<ul>\n<li>语法更紧凑</li>\n<li>结构更适于静态编译（比如静态类型检查，优化等）</li>\n<li>对于循环引用支持更好</li>\n</ul>\n<p>ES6 模块标准只有2部分，它的用法更简单，你根本不需要关注实现细节:</p>\n<ul>\n<li>声明式语法：模块导入import、导出export，没有require了</li>\n<li>程式化加载API：可以配置模块是如何加载，以及按需加载。</li>\n</ul>\n<h3>多模块管理器：Lerna</h3>\n<blockquote>\n<p>A tool for managing JavaScript projects with multiple packages.</p>\n</blockquote>\n<p><a href=\"https://lernajs.io/\">https://lernajs.io/</a></p>\n<p>在设计框架的时候，经常做的事儿是进行模块拆分，继而提供插件或集成机制，这样是非常好的做法。但问题也随之而来，当你的模块模块非常多时，你该如何管理你的模块呢？</p>\n<ul>\n<li>法1：每个模块都建立独立的仓库</li>\n<li>法2：所有模块都放到1个仓库里</li>\n</ul>\n<p>法1虽然看起来干净，但模块多时，依赖安装，不同版本兼容等，会导致模块间依赖混乱，出现非常多的重复依赖，极其容易造成版本问题。这时法2就显得更加有效，对于测试，代码管理，发布等，都可以做到更好的支持。</p>\n<p>Lerna就是基于这种初衷而产生的专门用于管理Node.js多模块的工具，当然，前提是你有很多模块需要管理。</p>\n<p>你可以通过npm全局模块来安装Lerna，官方推荐直接使用Lerna 2.x版本</p>\n<h3>更好的NPM替代品：Yarn</h3>\n<p>Yarn是开源JavaScript包管理器，由于npm在扩展内部使用时遇到了大小、性能和安全等问题，Facebook携手来自Exponent、Google和Tilde的工程师，在大型JavaScript框架上打造和测试了Yarn，以便其尽可能适用于多人开发。Yarn承诺比各大流行npm包的安装更可靠，且速度更快。根据你所选的工作包的不同，Yarn可以将安装时间从数分钟减少至几秒钟。Yarn还兼容npm注册表，但包安装方法有所区别。其使用了lockfiles和一个决定性安装算法，能够为参与一个项目的所有用户维持相同的节点模块（node_modules）目录结构，有助于减少难以追踪的bug和在多台机器上复制。</p>\n<p>Yarn还致力于让安装更快速可靠，支持缓存下载的每一个包和并行操作，允许在没有互联网连接的情况下安装（如果此前有安装过的话）。此外，Yarn承诺同时兼容npm和Bower工作流，让你限制安装模块的授权许可。</p>\n<p>2016年10月份, Yarn在横空出世不到一周的时间里，github上的star数已经过万，可以看出大厂及社区的活跃度，以及解决问题的诚意，大概无出其右了！</p>\n<p>替换的原因</p>\n<ul>\n<li>在Facebook的大规模 npm 都工作的不太好</li>\n<li>npm拖慢了公司的ci工作流</li>\n<li>对一个检查所有的模块也是相当低效的</li>\n<li>npm被设计为是不确定性的，而Facebook工程师需要为他们的DevOps工作流提供一直和可依赖的系统</li>\n</ul>\n<p>与hack npm限制的做法相反，Facebook编写了Yarn</p>\n<ul>\n<li>Yarn 的本地缓存文件做的更好</li>\n<li>Yarn 可以并行它的一些操作，这加速了对新模块的安装处理</li>\n<li>Yarn 使用lockfiles，并用确定的算法来创建一个所有跨机器上都一样的文件</li>\n<li>出于安全考虑，在安装进程里，Yarn 不允许编写包的开发者去执行其他代码</li>\n</ul>\n<blockquote>\n<p>Yarn, which promises to even give developers that don’t work at Facebook’s scale a major performance boost, still uses the npm registry and is essentially a drop-in replacement for the npm client.</p>\n</blockquote>\n<p>很多人说和ruby的gem机制类似，都生成lockfile。确实是一个很不错的改进，在速度上有很大改进，配置cnpm等国内源来用，还是相当爽的。</p>\n<h3>友好语言</h3>\n<ul>\n<li>过气的Coffeescript，不多说</li>\n<li><a href=\"https://babeljs.io/\">Babel</a> - also an ES6 to ES5 transpiler that’s growing in popularity possibly because it also supports React’s JSX syntax. As of today it supports the most ES6 features at a somewhat respectable 73%.</li>\n<li><a href=\"http://www.typescriptlang.org/\">TypeScript</a> - a typed superset of JavaScript that not only compiles ES6 to ES5 (or even ES3) but also supports optional variable typing. TypeScript only supports 53% of ES6 features.</li>\n</ul>\n<h2>总结</h2>\n<blockquote>\n<p>坦诚的力量是无穷的</p>\n</blockquote>\n<p>Node.js是为异步而生的，它自己把复杂的事儿做了（高并发，低延时），交给用户的只是有点难用的Callback写法。也正是坦诚的将异步回调暴露出来，才有更好的流程控制方面的演进。也正是这些演进，让Node.js从DIRT（数据敏感实时应用）扩展到更多的应用场景，今天的Node.js已经不只是能写后端的JavaScript，已经涵盖了所有涉及到开发的各个方面，而Node全栈更是热门种的热门。</p>\n<p>直面问题才能有更好的解决方式，Node.js你值得拥有！</p>\n</div>",
            "title": "2017，我们来聊聊 Node.js",
            "last_reply_at": "2017-05-25T11:57:49.856Z",
            "good": true,
            "top": true,
            "reply_count": 75,
            "visit_count": 18794,
            "create_at": "2017-04-13T02:41:41.818Z",
            "author": {
                "loginname": "i5ting",
                "avatar_url": "https://avatars0.githubusercontent.com/u/3118295?v=3&s=120"
            }
        },
        {
            "id": "5926b111d371b6372a8afdba",
            "author_id": "568aa899c2289f51658f07d4",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>最近用到 <a href=\"https://github.com/JacksonTian/eventproxy\">eventproxy</a>, 本着知其然的态度，分析了下其源码，有兴趣的可以看看。 <a href=\"https://github.com/gmailzj/eventproxy\">eventproxy源码分析</a></p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;*global define*&#x2F; !(function(name, definition) {\n    &#x2F;&#x2F; Check define\n    var hasDefine = typeof define === &#x27;function&#x27;,\n        &#x2F;&#x2F; Check exports\n        hasExports = typeof module !== &#x27;undefined&#x27; &amp;&amp; module.exports;\n\n    if (hasDefine) {\n        &#x2F;&#x2F; AMD Module or CMD Module\n        define(&#x27;eventproxy_debug&#x27;, function() { return function() {}; });\n        define([&#x27;eventproxy_debug&#x27;], definition);\n    } else if (hasExports) {\n        &#x2F;&#x2F; Node.js Module\n        module.exports = definition(require(&#x27;debug&#x27;)(&#x27;eventproxy&#x27;));\n    } else {\n        &#x2F;&#x2F; Assign to common namespaces or simply the global object (window)\n        this[name] = definition();\n    }\n})(&#x27;EventProxy&#x27;, function(debug) {\n    debug = debug || function() {};\n\n    &#x2F;*!\n     * refs\n     *&#x2F;\n    var SLICE = Array.prototype.slice;\n    var CONCAT = Array.prototype.concat;\n    var ALL_EVENT = &#x27;__all__&#x27;;\n\n    &#x2F;**\n     * EventProxy. An implementation of task&#x2F;event based asynchronous pattern.\n     * A module that can be mixed in to *any object* in order to provide it with custom events.\n     * You may &#96;bind&#96; or &#96;unbind&#96; a callback function to an event;\n     * &#96;trigger&#96;-ing an event fires all callbacks in succession.\n     * Examples:\n     * &#96;&#96;&#96;js\n     * var render = function (template, resources) {};\n     * var proxy = new EventProxy();\n     * proxy.assign(&quot;template&quot;, &quot;l10n&quot;, render);\n     * proxy.trigger(&quot;template&quot;, template);\n     * proxy.trigger(&quot;l10n&quot;, resources);\n     * &#96;&#96;&#96;\n     *&#x2F;\n    var EventProxy = function() {\n        &#x2F;&#x2F; 防止直接调用构造函数\n        if (!(this instanceof EventProxy)) {\n            return new EventProxy();\n        }\n        this._callbacks = {};\n        this._fired = {};\n    };\n\n    &#x2F;**\n     * Bind an event, specified by a string name, &#96;ev&#96;, to a &#96;callback&#96; function.\n     * Passing __ALL_EVENT__ will bind the callback to all events fired.\n     * Examples:\n     * &#96;&#96;&#96;js\n     * var proxy = new EventProxy();\n     * proxy.addListener(&quot;template&quot;, function (event) {\n     *   &#x2F;&#x2F; TODO\n     * });\n     * &#96;&#96;&#96;\n     * @param {String} eventname Event name.\n     * @param {Function} callback Callback.\n     *&#x2F;\n    EventProxy.prototype.addListener = function(ev, callback) {\n        &#x2F;&#x2F; 其实只是把事件处理回调 加入到回调队列，在trigger的时候用到\n        &#x2F;&#x2F; 程序中也可以单独对某件事件添加处理函数\n        debug(&#x27;Add listener for %s&#x27;, ev);\n        &#x2F;&#x2F; 常用手法 添加一项并且作为数组使用并且初始化，这样运行的时候不会出错\n        this._callbacks[ev] = this._callbacks[ev] || [];\n        &#x2F;&#x2F;  加入到回调队列中\n        this._callbacks[ev].push(callback);\n        return this;\n    };\n    &#x2F;**\n     * &#96;addListener&#96; alias, &#96;bind&#96;  ，&#96;on&#96;，&#96;subscribe&#96; 等价\n     *&#x2F;\n    EventProxy.prototype.bind = EventProxy.prototype.addListener;\n    &#x2F;**\n     * &#96;addListener&#96; alias, &#96;on&#96;\n     *&#x2F;\n    EventProxy.prototype.on = EventProxy.prototype.addListener;\n    &#x2F;**\n     * &#96;addListener&#96; alias, &#96;subscribe&#96;\n     *&#x2F;\n    EventProxy.prototype.subscribe = EventProxy.prototype.addListener;\n\n    &#x2F;**\n     * Bind an event, but put the callback into head of all callbacks.\n     * @param {String} eventname Event name.\n     * @param {Function} callback Callback.\n     *&#x2F;\n    EventProxy.prototype.headbind = function(ev, callback) {\n        &#x2F;&#x2F; 添加到事件处理队列的最前面\n        debug(&#x27;Add listener for %s&#x27;, ev);\n        this._callbacks[ev] = this._callbacks[ev] || [];\n        this._callbacks[ev].unshift(callback);\n        return this;\n    };\n\n    &#x2F;**\n     * Remove one or many callbacks. 取消事件处理回调\n     *\n     * - If &#96;callback&#96; is null, removes all callbacks for the event.\n     * - If &#96;eventname&#96; is null, removes all bound callbacks for all events.\n     * @param {String} eventname Event name.\n     * @param {Function} callback Callback.\n     *&#x2F;\n    EventProxy.prototype.removeListener = function(eventname, callback) {\n        var calls = this._callbacks;\n        if (!eventname) { &#x2F;&#x2F; 如果不加事件名，清除所有的回调\n            debug(&#x27;Remove all listeners&#x27;);\n            this._callbacks = {};\n        } else {\n            if (!callback) { &#x2F;&#x2F; 没有提供参数 回调，清除eventname事件的所有回调\n                debug(&#x27;Remove all listeners of %s&#x27;, eventname);\n                calls[eventname] = [];\n            } else { &#x2F;&#x2F; 得到事件名和回调\n                var list = calls[eventname];\n                if (list) {\n                    var l = list.length;\n                    for (var i = 0; i &lt; l; i++) {\n                        if (callback === list[i]) { &#x2F;&#x2F; 如果找到了回调 删除回调\n                            debug(&#x27;Remove a listener of %s&#x27;, eventname);\n                            list[i] = null;\n                        }\n                    }\n                }\n            }\n        }\n        return this;\n    };\n    &#x2F;**\n     * &#96;removeListener&#96; alias, unbind 等价\n     *&#x2F;\n    EventProxy.prototype.unbind = EventProxy.prototype.removeListener;\n\n    &#x2F;**\n     * Remove all listeners. It equals unbind()\n     * Just add this API for as same as Event.Emitter.\n     * @param {String} event Event name.\n     *&#x2F;\n    EventProxy.prototype.removeAllListeners = function(event) {\n        return this.unbind(event);\n    };\n\n    &#x2F;**\n     * Bind the ALL_EVENT event 注册 任务完成的 事件处理函数\n     *&#x2F;\n    EventProxy.prototype.bindForAll = function(callback) {\n        &#x2F;&#x2F;console.log(ALL_EVENT)\n        this.bind(ALL_EVENT, callback);\n    };\n\n    &#x2F;**\n     * Unbind the ALL_EVENT event  取消监听 任务完成\n     *&#x2F;\n    EventProxy.prototype.unbindForAll = function(callback) {\n        this.unbind(ALL_EVENT, callback);\n    };\n\n    &#x2F;**\n     * Trigger an event, firing all bound callbacks. Callbacks are passed the\n     * same arguments as &#96;trigger&#96; is, apart from the event name.\n     * Listening for &#96;&quot;all&quot;&#96; passes the true event name as the first argument.\n     * @param {String} eventname Event name\n     * @param {Mix} data Pass in data\n     *&#x2F;\n    EventProxy.prototype.trigger = function(eventname, data) {\n        debug(&quot;trigger:&quot;, eventname)\n        var list, ev, callback, i, l;\n        var both = 2;\n        var calls = this._callbacks;\n        &#x2F;&#x2F; console.log(calls);\n        debug(&#x27;Emit event %s with data %j&#x27;, eventname, data);\n        while (both--) {\n            &#x2F;&#x2F; 注意第一次运行到这里 both已经等于1了，如果是等于0，说明是用来最后处理ALL_EVENT(全部完成的事件bindForAll)\n            &#x2F;&#x2F; 也就是说 每一次trigger单个事件的时候，其实也会触发ALL_EVENT事件，\n            &#x2F;&#x2F; 但是ALL_EVENT事件是否完成，最终的判断是在_assign函数的_all函数中\n\n            &#x2F;&#x2F; 事件名\n            ev = both ? eventname : ALL_EVENT;\n            list = calls[ev]; &#x2F;&#x2F; 得到回调列表\n            if (list) {\n                &#x2F;&#x2F; 遍历所有的回调, 一个事件可能有多个绑定回调，比如用户自定义bind\n                for (i = 0, l = list.length; i &lt; l; i++) {\n                    &#x2F;&#x2F; 注意上一轮(both=1)的回调\n\n                    &#x2F;&#x2F; 有两种可能：\n                    &#x2F;&#x2F; 1 用户自定回调为false，\n                    &#x2F;&#x2F; 2 单个事件回调已经执行了, 会在removeListener中执行 unbind，\n                    if (!(callback = list[i])) {\n                        debug(callback, &#x27;alert&#x27;)\n                            &#x2F;&#x2F; 删掉该list中的item\n                        list.splice(i, 1);\n\n                        &#x2F;&#x2F; 下面两行相当于重来一次循环判断\n                        i--;\n                        l--;\n                    } else { &#x2F;&#x2F; callback 为真\n                        &#x2F;&#x2F; console.log(callback)\n                        var args = [];\n                        &#x2F;&#x2F; 如果是单个事件 过滤掉第一个参数 事件名，只要data\n                        &#x2F;&#x2F; ALL_EVENT的话，需要包括事件名, after方法中有用到事件名和data\n                        var start = both ? 1 : 0;\n                        for (var j = start; j &lt; arguments.length; j++) {\n                            args.push(arguments[j]);\n                        }\n                        &#x2F;&#x2F; console.log(args);\n                        &#x2F;&#x2F; callback 必须是函数，用户自定义bind的时候，没有强制规定\n                        callback.apply(this, args);\n                    }\n                }\n            }\n        }\n        return this;\n    };\n\n    &#x2F;**\n     * &#96;trigger&#96; alias  emit、trigger、fire 等价 都是触发事件的意思\n     *&#x2F;\n    EventProxy.prototype.emit = EventProxy.prototype.trigger;\n    &#x2F;**\n     * &#96;trigger&#96; alias\n     *&#x2F;\n    EventProxy.prototype.fire = EventProxy.prototype.trigger;\n\n    &#x2F;**\n     * Bind an event like the bind method, but will remove the listener after it was fired.\n     * @param {String} ev Event name\n     * @param {Function} callback Callback\n     *&#x2F;\n    EventProxy.prototype.once = function(ev, callback) {\n        &#x2F;&#x2F; 和bind的区别就是\n        var self = this;\n        &#x2F;&#x2F; 里面包装一个unbind, 当第一次执行以后，unbind，就相当于只能once\n        var wrapper = function() {\n            &#x2F;&#x2F;console.log(arguments)\n            &#x2F;&#x2F; 这里arguments是指真正 wrapper 执行的时候的参数\n            callback.apply(self, arguments);\n            self.unbind(ev, wrapper);\n        };\n\n        &#x2F;&#x2F; 真正绑定\n        this.bind(ev, wrapper);\n        return this;\n    };\n\n    &#x2F;&#x2F; later等于下面的三个选择之一 。优先级：setImmediate &gt; process.nextTick &gt; setTimeout(fn, 0);\n    var later = (typeof setImmediate !== &#x27;undefined&#x27; &amp;&amp; setImmediate) ||\n        (typeof process !== &#x27;undefined&#x27; &amp;&amp; process.nextTick) || function(fn) {\n            setTimeout(fn, 0);\n        };\n\n    &#x2F;**\n     * emitLater\n     * make emit async  异步事件触发\n     *&#x2F;\n    EventProxy.prototype.emitLater = function() {\n        var self = this;\n        var args = arguments;\n        later(function() { &#x2F;&#x2F; 通过上面的later方案\n            self.trigger.apply(self, args);\n        });\n    };\n\n    &#x2F;**\n     * Bind an event, and trigger it immediately.  绑定并立即执行，传递 事件名、事件发生以后的回调、触发时传递的数据\n     * @param {String} ev Event name.\n     * @param {Function} callback Callback.\n     * @param {Mix} data The data that will be passed to calback as arguments.\n     *&#x2F;\n    EventProxy.prototype.immediate = function(ev, callback, data) {\n        this.bind(ev, callback);\n        this.trigger(ev, data);\n        return this;\n    };\n    &#x2F;**\n     * &#96;immediate&#96; alias 和 immediate 别名等价\n     *&#x2F;\n    EventProxy.prototype.asap = EventProxy.prototype.immediate;\n\n    &#x2F;&#x2F; 设置最终回调和事件列表\n    var _assign = function(eventname1, eventname2, cb, once) {\n        &#x2F;&#x2F; 引用this\n        var proxy = this;\n        var argsLength = arguments.length;\n        var times = 0;\n        var flag = {};\n\n        &#x2F;&#x2F; Check the arguments length. 最起码有3个参数：一个事件名和一个回调和一个标记once(内部赋值，::all方法里面)\n        if (argsLength &lt; 3) {\n            return this;\n        }\n\n        &#x2F;&#x2F; 所有的事件参数\n        var events = SLICE.call(arguments, 0, -2);\n\n        &#x2F;&#x2F; 最终回调cb\n        var callback = arguments[argsLength - 2];\n\n        &#x2F;&#x2F; true 表示isOnce为真，all的时候赋值为 true\n        var isOnce = arguments[argsLength - 1];\n\n        &#x2F;&#x2F; Check the callback type.\n        if (typeof callback !== &quot;function&quot;) {\n            return this;\n        }\n        debug(&#x27;Assign listener for events %j, once is %s&#x27;, events, !!isOnce);\n\n        &#x2F;&#x2F; key 表示的是 事件名\n        var bind = function(key) {\n            &#x2F;&#x2F; 根据isOnce判断method为once或者bind\n            var method = isOnce ? &quot;once&quot; : &quot;bind&quot;;\n\n            &#x2F;&#x2F; 在这里绑定每个事件handler proxy[method] 对应 this.once、this.bind方法\n            &#x2F;&#x2F; 在应用中的区别就是\n            &#x2F;&#x2F; ep.tail的时候会使用bind，这样只要事件成功触发过，然后重复提交任意其中1个事件(tail绑定) 都会触发ALL_EVENT\n            proxy[method](key, function(data) {\n                &#x2F;&#x2F; 这里才是真正的单个事件处理 handler\n\n                &#x2F;&#x2F; this._fired[key] 初始化\n                proxy._fired[key] = proxy._fired[key] || {};\n\n                &#x2F;&#x2F; 存储已经触发的事件的数据, ALL_EVENT回调用到\n                proxy._fired[key].data = data;\n                &#x2F;&#x2F; flag[key]列表中标记key 不存在的时候表示第一次触发事件才是是真正合法的\n                if (!flag[key]) {\n                    flag[key] = true;\n                    times++;\n                }\n            });\n        };\n\n        &#x2F;&#x2F; 绑定多个自定义事件\n        var length = events.length;\n        for (var index = 0; index &lt; length; index++) {\n            bind(events[index]); &#x2F;&#x2F; 参数为事件名key\n        }\n        &#x2F;&#x2F; ALL_EVENT 回调, 但是不代表真正完成ALL_EVENT，单个事件触发的时候也会这些这里，然后在里面判断是否完成\n        &#x2F;&#x2F; 第一个参数\n        var _all = function(event) {\n            console.log(&#x27;开始ALL_EVENT 是否完成判断：&#x27;, times, length, flag[event], event);\n\n            &#x2F;&#x2F; &#x27;开始ALL_EVENT 是否完成判断：&#x27;\n            if (times &lt; length) { &#x2F;&#x2F; 如果事件触发的次数小于总的事件数量\n                return;\n            }\n            if (!flag[event]) {\n                return;\n            }\n            var data = [];\n            &#x2F;&#x2F; 这里就是获取ALL_EVENT回调的参数\n            for (var index = 0; index &lt; length; index++) {\n                data.push(proxy._fired[events[index]].data);\n            }\n            if (isOnce) { &#x2F;&#x2F; 如果是一次性事件，注册ubindForAll事件处理\n                proxy.unbindForAll(_all);\n            }\n            debug(&#x27;Events %j all emited with data %j&#x27;, events, data);\n            &#x2F;&#x2F; 真正传递数据并执行回调\n            callback.apply(null, data);\n        };\n        proxy.bindForAll(_all);\n    };\n\n    &#x2F;**\n     * Assign some events, after all events were fired, the callback will be executed once.\n     *\n     * Examples:\n     * &#96;&#96;&#96;js\n     * proxy.all(ev1, ev2, callback);\n     * proxy.all([ev1, ev2], callback);\n     * proxy.all(ev1, [ev2, ev3], callback);\n     * &#96;&#96;&#96;\n     * @param {String} eventname1 First event name.\n     * @param {String} eventname2 Second event name.\n     * @param {Function} callback Callback, that will be called after predefined events were fired.\n     *&#x2F;\n    EventProxy.prototype.all = function(eventname1, eventname2, callback) {\n        &#x2F;&#x2F; 主要是为了合并事件参数\n        var args = CONCAT.apply([], arguments);\n        args.push(true);\n        &#x2F;&#x2F; console.log(args)\n        _assign.apply(this, args);\n        return this;\n    };\n    &#x2F;**\n     * &#96;all&#96; alias\n     *&#x2F;\n    EventProxy.prototype.assign = EventProxy.prototype.all;\n\n    &#x2F;**\n     * Assign the only one &#x27;error&#x27; event handler.\n     * @param {Function(err)} callback\n     *&#x2F;\n    EventProxy.prototype.fail = function(callback) {\n        var that = this;\n\n        that.once(&#x27;error&#x27;, function() {\n            that.unbind();\n            &#x2F;&#x2F; put all arguments to the error handler\n            &#x2F;&#x2F; fail(function(err, args1, args2, ...){})\n            callback.apply(null, arguments);\n        });\n        return this;\n    };\n\n    &#x2F;**\n     * A shortcut of ep#emit(&#x27;error&#x27;, err)\n     *&#x2F;\n    EventProxy.prototype.throw = function() {\n        var that = this;\n        that.emit.apply(that, [&#x27;error&#x27;].concat(SLICE.call(arguments)));\n    };\n\n    &#x2F;**\n     * Assign some events, after all events were fired, the callback will be executed first time.\n     * Then any event that predefined be fired again, the callback will executed with the newest data.\n     * Examples:\n     * &#96;&#96;&#96;js\n     * proxy.tail(ev1, ev2, callback);\n     * proxy.tail([ev1, ev2], callback);\n     * proxy.tail(ev1, [ev2, ev3], callback);\n     * &#96;&#96;&#96;\n     * @param {String} eventname1 First event name.\n     * @param {String} eventname2 Second event name.\n     * @param {Function} callback Callback, that will be called after predefined events were fired.\n     *&#x2F;\n    EventProxy.prototype.tail = function() {\n        var args = CONCAT.apply([], arguments);\n        args.push(false); &#x2F;&#x2F; 和EventProxy.prototype.all的唯一区别 true=&gt;false，从而来控制bind 和once\n        _assign.apply(this, args);\n        return this;\n    };\n    &#x2F;**\n     * &#96;tail&#96; alias, assignAll\n     *&#x2F;\n    EventProxy.prototype.assignAll = EventProxy.prototype.tail;\n    &#x2F;**\n     * &#96;tail&#96; alias, assignAlways\n     *&#x2F;\n    EventProxy.prototype.assignAlways = EventProxy.prototype.tail;\n\n    &#x2F;**\n     * The callback will be executed after the event be fired N times.\n     * @param {String} eventname Event name.\n     * @param {Number} times N times.\n     * @param {Function} callback Callback, that will be called after event was fired N times.\n     *&#x2F;\n    EventProxy.prototype.after = function(eventname, times, callback) {\n        &#x2F;&#x2F; 重复异步协作\n        &#x2F;&#x2F; 如果参数times为0，直接执行回调, 参数为数组[]\n        if (times === 0) {\n            callback.call(null, []);\n            return this;\n        }\n        var proxy = this,\n            firedData = [];\n        &#x2F;&#x2F; _after 初始化\n        this._after = this._after || {};\n        &#x2F;&#x2F; 根据事件名设置分组名\n        var group = eventname + &#x27;_group&#x27;;\n        &#x2F;&#x2F; 存储分组事件的数据\n        this._after[group] = {\n            index: 0,\n            results: []\n        };\n        debug(&#x27;After emit %s times, event %s\\&#x27;s listenner will execute&#x27;, times, eventname);\n\n        &#x2F;&#x2F; 设置所有事件完成以后的回调\n        var all = function(name, data) {\n            if (name === eventname) { &#x2F;&#x2F; 到处都是闭包 事件名\n                times--;\n                &#x2F;&#x2F; 将数据添加到list列表\n                firedData.push(data);\n                if (times &lt; 1) { &#x2F;&#x2F; 说明已经完成了\n                    debug(&#x27;Event2 %s was emit %s, and execute the listenner&#x27;, eventname, times);\n                    &#x2F;&#x2F; 解绑事件监听\n                    proxy.unbindForAll(all);\n                    &#x2F;&#x2F; 事件完成调用回调\n                    callback.apply(null, [firedData]);\n                }\n            }\n            if (name === group) { &#x2F;&#x2F; 到处都是闭包 事件组名 ep.group(&#x27;got_file&#x27;) ,实际是ep.emit的groupname\n                times--;\n                &#x2F;&#x2F; 换一种group方式将数据添加到list列表\n                proxy._after[group].results[data.index] = data.result;\n                if (times &lt; 1) { &#x2F;&#x2F; 说明已经完成了\n                    debug(&#x27;Event %s was emit %s, and execute the listenner&#x27;, eventname, times);\n                    &#x2F;&#x2F; 解绑事件监听\n                    proxy.unbindForAll(all);\n                    &#x2F;&#x2F; 事件完成调用回调\n                    callback.call(null, proxy._after[group].results);\n                }\n            }\n        };\n        proxy.bindForAll(all);\n        return this;\n    };\n\n    &#x2F;**\n     * The &#96;after&#96; method&#x27;s helper. Use it will return ordered results.\n     * If you need manipulate result, you need callback\n     * Examples:\n     * &#96;&#96;&#96;js\n     * var ep = new EventProxy();\n     * ep.after(&#x27;file&#x27;, files.length, function (list) {\n     *   &#x2F;&#x2F; Ordered results\n     * });\n     * for (var i = 0; i &lt; files.length; i++) {\n     *   fs.readFile(files[i], &#x27;utf-8&#x27;, ep.group(&#x27;file&#x27;));\n     * }\n     * &#96;&#96;&#96;\n     * @param {String} eventname Event name, shoule keep consistent with &#96;after&#96;.\n     * @param {Function} callback Callback function, should return the final result.\n     *&#x2F;\n    EventProxy.prototype.group = function(eventname, callback) {\n        var that = this;\n        var group = eventname + &#x27;_group&#x27;; &#x2F;&#x2F; 分组名称\n        var index = that._after[group].index;\n        that._after[group].index++;\n        return function(err, data) {\n            if (err) { &#x2F;&#x2F; 错误处理\n                &#x2F;&#x2F; put all arguments to the error handler 提交错误\n                return that.emit.apply(that, [&#x27;error&#x27;].concat(SLICE.call(arguments)));\n            }\n            that.emit(group, { &#x2F;&#x2F; 提交事件组\n                index: index,\n                &#x2F;&#x2F; callback(err, args1, args2, ...) 如果ep.group()的时候提供了callback参数，就是增加中间层加工data\n                result: callback ? callback.apply(null, SLICE.call(arguments, 1)) : data\n            });\n        };\n    };\n\n    &#x2F;**\n     * The callback will be executed after any registered event was fired. It only executed once.\n     * 回调将在任意一个注册了的事件触发以后执行，而且只执行一次\n     * @param {String} eventname1 Event name.\n     * @param {String} eventname2 Event name.\n     * @param {Function} callback The callback will get a map that has data and eventname attributes.\n     *&#x2F;\n    EventProxy.prototype.any = function() {\n        var proxy = this,\n            callback = arguments[arguments.length - 1], &#x2F;&#x2F; 最后一个参数为callback\n            events = SLICE.call(arguments, 0, -1), &#x2F;&#x2F; 事件名数组\n            _eventname = events.join(&quot;_&quot;); &#x2F;&#x2F; eg:  event1_event2_event3\n\n        debug(&#x27;Add listenner for Any of events %j emit&#x27;, events);\n        proxy.once(_eventname, callback); &#x2F;&#x2F; 只执行一次\n\n        var _bind = function(key) {\n            proxy.bind(key, function(data) { &#x2F;&#x2F; 对每一个事件绑定\n                debug(&#x27;One of events %j emited, execute the listenner&#x27;);\n                proxy.trigger(_eventname, { &quot;data&quot;: data, eventName: key }); &#x2F;&#x2F; 触发&#96;event1_event2_event3&#96;事件\n            });\n        };\n\n        for (var index = 0; index &lt; events.length; index++) {\n            _bind(events[index]);\n        }\n    };\n\n    &#x2F;**\n     * The callback will be executed when the event name not equals with assigned event.\n     * @param {String} eventname Event name.\n     * @param {Function} callback Callback.\n     *&#x2F;\n    EventProxy.prototype.not = function(eventname, callback) {\n        var proxy = this;\n        debug(&#x27;Add listenner for not event %s&#x27;, eventname);\n\n        &#x2F;&#x2F; 这里绑定 ALL_EVENT  ，在trigger单个事件的时候，在trigger方法里面会有ALL_EVENT的判断\n        proxy.bindForAll(function(name, data) {\n            if (name !== eventname) {\n                debug(&#x27;listenner execute of event %s emit, but not event %s.&#x27;, name, eventname);\n                callback(data); &#x2F;&#x2F; 传递数据并执行回调\n            }\n        });\n    };\n\n    &#x2F;**\n     * Success callback wrapper, will handler err for you.\n     *\n     * &#96;&#96;&#96;js\n     * fs.readFile(&#x27;foo.txt&#x27;, ep.done(&#x27;content&#x27;));\n     *\n     * &#x2F;&#x2F; equal to =&gt;\n     *\n     * fs.readFile(&#x27;foo.txt&#x27;, function (err, content) {\n     *   if (err) {\n     *     return ep.emit(&#x27;error&#x27;, err);\n     *   }\n     *   ep.emit(&#x27;content&#x27;, content);\n     * });\n     * &#96;&#96;&#96;\n     *\n     * &#96;&#96;&#96;js\n     * fs.readFile(&#x27;foo.txt&#x27;, ep.done(&#x27;content&#x27;, function (content) {\n     *   return content.trim();\n     * }));\n     *\n     * &#x2F;&#x2F; equal to =&gt;\n     *\n     * fs.readFile(&#x27;foo.txt&#x27;, function (err, content) {\n     *   if (err) {\n     *     return ep.emit(&#x27;error&#x27;, err);\n     *   }\n     *   ep.emit(&#x27;content&#x27;, content.trim());\n     * });\n     * &#96;&#96;&#96;\n     * @param {Function|String} handler, success callback or event name will be emit after callback.\n     * @return {Function}\n     *&#x2F;\n    EventProxy.prototype.done = function(handler, callback) {\n        var that = this;\n        return function(err, data) {\n\n            if (err) {\n                &#x2F;&#x2F; put all arguments to the error handler\n                &#x2F;&#x2F; 如果出错了，提交error\n                return that.emit.apply(that, [&#x27;error&#x27;].concat(SLICE.call(arguments)));\n            }\n\n            &#x2F;&#x2F; callback(err, args1, args2, ...)\n            &#x2F;&#x2F; 得到数据\n            var args = SLICE.call(arguments, 1);\n\n            if (typeof handler === &#x27;string&#x27;) { &#x2F;&#x2F; 如果第一个参数是字符串\n                &#x2F;&#x2F; getAsync(query, ep.done(&#x27;query&#x27;));\n                &#x2F;&#x2F; or\n                &#x2F;&#x2F; getAsync(query, ep.done(&#x27;query&#x27;, function (data) {\n                &#x2F;&#x2F;   return data.trim();\n                &#x2F;&#x2F; }));\n                if (callback) { &#x2F;&#x2F; 如果有回调，其实就是数据加工函数\n                    &#x2F;&#x2F; only replace the args when it really return a result\n                    return that.emit(handler, callback.apply(null, args));\n                } else {\n                    &#x2F;&#x2F; put all arguments to the done handler\n                    &#x2F;&#x2F;ep.done(&#x27;some&#x27;);\n                    &#x2F;&#x2F;ep.on(&#x27;some&#x27;, function(args1, args2, ...){});  触发事件，并传递数据\n                    return that.emit.apply(that, [handler].concat(args));\n                }\n            }\n\n            &#x2F;&#x2F; speed improve for mostly case: &#96;callback(err, data)&#96;\n            if (arguments.length &lt;= 2) { &#x2F;&#x2F; 第一个参数是函数 需要手动emit\n                &#x2F;&#x2F; console.log(&quot;&lt;=2&quot;)\n                return handler(data);\n            }\n\n            &#x2F;&#x2F; callback(err, args1, args2, ...)\n            handler.apply(null, args);\n            &#x2F;&#x2F; console.log(&quot;last&quot;)\n        };\n    };\n\n    &#x2F;**\n     * make done async\n     * @return {Function} delay done\n     *&#x2F;\n    EventProxy.prototype.doneLater = function(handler, callback) {\n        var _doneHandler = this.done(handler, callback);\n        return function(err, data) {\n            var args = arguments;\n            later(function() {\n                _doneHandler.apply(null, args);\n            });\n        };\n    };\n\n    &#x2F;**\n     * Create a new EventProxy\n     * Examples:\n     * &#96;&#96;&#96;js\n     * var ep = EventProxy.create();\n     * ep.assign(&#x27;user&#x27;, &#x27;articles&#x27;, function(user, articles) {\n     *   &#x2F;&#x2F; do something...\n     * });\n     * &#x2F;&#x2F; or one line ways: Create EventProxy and Assign\n     * var ep = EventProxy.create(&#x27;user&#x27;, &#x27;articles&#x27;, function(user, articles) {\n     *   &#x2F;&#x2F; do something...\n     * });\n     * &#96;&#96;&#96;\n     * @return {EventProxy} EventProxy instance\n     *&#x2F;\n    EventProxy.create = function() {\n        var ep = new EventProxy();\n        var args = CONCAT.apply([], arguments);\n        if (args.length) {\n            &#x2F;&#x2F; 假设最后1个是errorHandler, 倒数第2个是回调\n            var errorHandler = args[args.length - 1];\n            var callback = args[args.length - 2];\n            if (typeof errorHandler === &#x27;function&#x27; &amp;&amp; typeof callback === &#x27;function&#x27;) {\n\n                &#x2F;&#x2F; 处理好errorHandler,\n                args.pop();\n                ep.fail(errorHandler);\n            }\n            &#x2F;&#x2F; 开始真正的assign\n            ep.assign.apply(ep, args);\n        }\n        return ep;\n    };\n\n    &#x2F;&#x2F; Backwards compatibility\n    EventProxy.EventProxy = EventProxy;\n\n    return EventProxy;\n});\n</code></pre></div>",
            "title": "eventproxy 原理分析",
            "last_reply_at": "2017-05-26T03:09:41.812Z",
            "good": false,
            "top": false,
            "reply_count": 1,
            "visit_count": 88,
            "create_at": "2017-05-25T10:25:21.892Z",
            "author": {
                "loginname": "gmailzj",
                "avatar_url": "https://avatars3.githubusercontent.com/u/2996820?v=3&s=120"
            }
        },
        {
            "id": "5926e6f09e32cc84569a738e",
            "author_id": "591eea623504ce1c2ac45e58",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>项目地址: <a href=\"https://github.com/loon-project/loon\">https://github.com/loon-project/loon</a></p>\n<p>抄一段我写在文档里面的代码。</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 定义一个事件发布者\n\n@Service()\nclass CustomEventEmitter extends EventEmitter {}\n\n&#x2F;&#x2F; 定义一个事件订阅者\n\n@Subscriber()\nclass CustomEventSubscriber {\n\n  private property = &quot;a property&quot;;\n\n  &#x2F;&#x2F; 用 &#96;On&#96; 注册了 &#96;newEvent&#96; 事件的回调\n  @On(&#x27;newEvent&#x27;, CustomEventEmitter)\n  public onEventEmit() {\n    this.property === &quot;a property&quot; &#x2F;&#x2F; =&gt; true\n  }\n}\n\nconst emitter = DependencyRegistry.get(CustomEventEmitter);\nemitter.emit(&#x27;newEvent&#x27;);\n</code></pre><p>当事件发布者发布一个消息时，事件订阅者马上会触发注册的方法。 &lt;br&gt;\n&lt;b&gt;重要: 在订阅者方法中的this是订阅者本身&lt;/b&gt;</p>\n<h3>上次发的介绍框架其他细节的帖子内容</h3>\n<p>一个类似于springmvc的nodejs框架，内置了常用的express包，有丰富的可选配置，依赖注入.\n<a href=\"https://github.com/loon-project/loon\">项目地址</a>\n<a href=\"https://loon-project.github.io/#/zh-cn/\">文档</a></p>\n<h2>功能</h2>\n<ul>\n<li>依赖注入</li>\n<li>服务类</li>\n<li>Result 路由和控制器</li>\n<li>中间件</li>\n<li>过滤器</li>\n<li>模型</li>\n<li>转化器</li>\n<li>启动器</li>\n</ul>\n<h2>快速开始</h2>\n<p>&lt;br&gt;</p>\n<ul>\n<li>克隆 loon-boilerplate 项目</li>\n</ul>\n<pre class=\"prettyprint language-bash\"><code>$ git clone https:&#x2F;&#x2F;github.com&#x2F;loon-project&#x2F;loon-boilerplate\n$ cd loon-boilerplate\n$ npm install\n</code></pre><ul>\n<li>开始编译typescript并启动服务器</li>\n</ul>\n<pre class=\"prettyprint language-bash\"><code>$ npm run dev\n</code></pre><ul>\n<li>在浏览器中测试 <a href=\"http://localhost:9000\">http://localhost:9000</a></li>\n</ul>\n<h2>控制器</h2>\n<pre class=\"prettyprint language-typescript\"><code>@RestController(&#x27;&#x2F;admin&#x27;)\nclass AdminController {\n\n  @Get(&#x27;&#x2F;users&#x2F;:id&#x27;)\n  public userAction(@PathParam(&#x27;id&#x27;) id: number) {\n      # incoming request is &#x2F;admin&#x2F;users&#x2F;1\n      # then id inside this action would be 1\n  }\n\n  @Get(&#x27;&#x2F;users&#x27;)\n  public listUsersAction(@QueryParam(&#x27;is_active&#x27;) isActive: boolean) {\n      # incoming request is &#x2F;admin&#x2F;users?is_active=true\n      # then isActive inside this action would be true\n\n      isAction === true # =&gt; true\n  }\n\n  @Post(&#x27;&#x2F;users&#x27;)\n  public createUserAction(@BodyParam(&#x27;user&#x27;) user: any) {\n      # incoming request is POST &#x2F;admin&#x2F;users with json body\n      # {\n      #   user: {name: &quot;Jack&quot;}\n      # }\n      # then the user inside this action would be a object\n\n      user.name === &quot;Jack&quot; # =&gt; true\n  }\n}\n</code></pre><h2>过滤器</h2>\n<p><code>AuthenticateFilter</code> 前置过滤器检查是否用户已经登陆，\n如果用户还没有登陆， 就直接返回 403 状态码。</p>\n<p>使用时 <code>AuthenticatedResourceController</code> 加上一个 <code>@BeforeFilter(AuthenticateFilter)</code> 的注解,\n这就意味着所有这个 Controller 里面的 路由都会使用前置过滤器 <code>AuthenticateFilter</code>。\n如果这个 Controller 需要几个能让匿名用户访问的路由, 可以在使用注解时加上参数来达到部分使用过滤器的目的。</p>\n<pre class=\"prettyprint language-typescript\"><code>@Filter()\nclass AuthenticateFilter implements IMiddleware {\n\n  public use(@Res() res: Express.Response, @Next() next: Express.NextFunction) {\n    if (&#x2F;&#x2F; use is logged in) {\n      next();\n    } else {\n      res.sendStatus(403);\n    }\n  }\n}\n\n@RestController()\n@BeforeFilter(AuthenticateFilter)\nclass AuthenticatedResourceController {}\n</code></pre><h2>中间件</h2>\n<p>注解了 <code>@Middleware</code> 并且实现了 <code>IMiddleware</code> 的类自动会识别并加载为 <code>Middleware</code>。</p>\n<pre class=\"prettyprint language-typescript\"><code>@Middleware({order: 0})\nclass ELKMiddleware implements IMiddleware {\n\n  public use(@Next() next: Express.NextFunction) {\n    &#x2F;&#x2F; start tracking\n    next()\n    &#x2F;&#x2F; end tracking\n    &#x2F;&#x2F; send to elk\n  }\n}\n</code></pre><h2>错误中间件</h2>\n<p><code>@ErrorMiddleware</code> 用法和 <code>@Middleware</code> 基本一样, 有一个不同点是你能通过 <code>@Err</code> 拿到错误 Object。</p>\n<pre class=\"prettyprint language-typescript\"><code>@ErrorMiddleware()\nclass ExceptionHandler implements IMiddleware {\n\n  public use(@Err() err: any, @Res() res: Express.Response) {\n    console.log(err.message);\n    res.sendStatus(400);\n  }\n}\n</code></pre><h2>模型</h2>\n<p>模型通过添加 <code>@Property</code> 注解增加了转化的能力。</p>\n<pre class=\"prettyprint language-typescript\"><code>\nclass User {\n\n  @Property()\n  firstName: string;\n\n  @Property()\n  lastName: string;\n}\n\n@RestController(&quot;&#x2F;users&quot;)\nclass UserController {\n\n  @Post(&quot;&quot;)\n  public createAction(@BodyParam(&#x27;user&#x27;) user: User) {\n    user instanceof User # =&gt; true\n  }\n}\n</code></pre><p>控制器中的参数 <code>user</code> 制定了类是 <code>User</code>, 当带有 http body 的请求到来时:</p>\n<pre class=\"prettyprint\"><code>{\n  user: {\n    firstName: &quot;Jack&quot;,\n    lastName: &quot;Hai&quot;\n  }\n}\n</code></pre><p>user 这个变量会自动的转化成 <code>User</code> model 的实例。</p>\n<h2>自定义转化器</h2>\n<p>属性也支持传一个实现了 <code>IConverter</code> 借口的类作为自定义转化器。</p>\n<pre class=\"prettyprint language-typescript\"><code>@Service()\nexport class MomentConverter implements IConverter {\n\n    public deserialize(data: any, klassProperty: string, objectProperty: string): any {\n        const value = data[objectProperty];\n\n        if (typeof value === &#x27;undefined&#x27;) {\n            return;\n        }\n\n        const m = Moment.utc(value);\n\n        if (m.isValid()) {\n            return m;\n        }\n\n        return;\n    }\n}\n\nclass User {\n\n  @Property({converter: MomentConverter})\n  public registerDate: Moment.Moment;\n}\n</code></pre><p>这个例子显示了如何写一个转化 <code>string/Date</code> 对象到 <code>moment</code> utc 对象。</p>\n<h2>服务</h2>\n<pre class=\"prettyprint language-typescript\"><code>\n@Service()\nclass UserService {\n  &#x2F;&#x2F; any logic\n}\n\n@RestController(&#x27;&#x2F;users&#x27;)\nclass UserController {\n  @Inject()\n  private userService: UserService;\n\n  @Get(&#x27;&#x27;)\n  public indexAction() {\n    this.userService.listUsers();\n  }\n}\n</code></pre><p>在例子中, <code>UserService</code> 注解了 <code>@Service</code>, 然后被注入在了 <code>UserController</code>。</p>\n<p><a href=\"https://loon-project.github.io/#/zh-cn/\">文档</a>更多详细的说明</p>\n<p>欢迎star，fork还有各种issues\n<a href=\"https://github.com/loon-project/loon\">项目地址</a></p>\n</div>",
            "title": "气球(Loon) Nodejs框架发布v1.1.0,啦 支持事件的订阅和发布",
            "last_reply_at": "2017-05-26T02:53:32.211Z",
            "good": false,
            "top": false,
            "reply_count": 11,
            "visit_count": 144,
            "create_at": "2017-05-25T14:15:12.143Z",
            "author": {
                "loginname": "vincent178",
                "avatar_url": "https://avatars1.githubusercontent.com/u/2183720?v=3&s=120"
            }
        },
        {
            "id": "5926bd4f9e32cc84569a736a",
            "author_id": "5926aaf7ba8670562a40f4e0",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>对于新手来说在It这方面表现的本来就不理想，更没有什么好的学习方法，跪求大神指点</p>\n</div>",
            "title": "服务器搭建怎么记的更快些，有没有什么有效的方法",
            "last_reply_at": "2017-05-26T02:53:05.468Z",
            "good": false,
            "top": false,
            "reply_count": 2,
            "visit_count": 98,
            "create_at": "2017-05-25T11:17:35.890Z",
            "author": {
                "loginname": "fanpingxin",
                "avatar_url": "https://avatars3.githubusercontent.com/u/28948396?v=3&s=120"
            }
        },
        {
            "id": "59278ad6d371b6372a8afdff",
            "author_id": "53819b20a087f456201b8f13",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>现在的业务系统产生的数据做一些数据统计。\n现在的倾向是直接再做一个服务去做这件事情，但是问题是我再开一个服务的话，</p>\n<ol>\n<li>数据是由业务系统提供接口获取好，</li>\n<li>还是直接链接业务系统的数据库拿。</li>\n<li>还是有什么更好的方案。</li>\n</ol>\n</div>",
            "title": "求教～统计显示的时候，统计是由于业务服务直接做好，还是专门的统计服务去做？如何做呢？",
            "last_reply_at": "2017-05-26T02:36:24.821Z",
            "good": false,
            "top": false,
            "reply_count": 4,
            "visit_count": 44,
            "create_at": "2017-05-26T01:54:30.105Z",
            "author": {
                "loginname": "koroshi",
                "avatar_url": "https://avatars3.githubusercontent.com/u/7600053?v=3&s=120"
            }
        },
        {
            "id": "5926bbbcba8670562a40f4e6",
            "author_id": "53b25565399ed9e07d1e8793",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>我用express-generator初始化了一个项目 ，放到electron的demo里，然后在express项目里加入了mongoose，再之后启动后窗口就是空白的</p>\n<p>求问有人折腾过这个没，求指教</p>\n</div>",
            "title": "用electron+express开发桌面应用，有用过连接数据库的吗？",
            "last_reply_at": "2017-05-26T02:36:16.377Z",
            "good": false,
            "top": false,
            "reply_count": 5,
            "visit_count": 122,
            "create_at": "2017-05-25T11:10:52.311Z",
            "author": {
                "loginname": "liygheart",
                "avatar_url": "https://avatars1.githubusercontent.com/u/6915570?v=3&s=120"
            }
        },
        {
            "id": "592065829e32cc84569a717f",
            "author_id": "59145d403504ce1c2ac45af3",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>最近花了很多时间选择ORM\n主要体验了sequelize和bookshelfjs，感觉bookshelfjs更好，理由如下：</p>\n<h3>sequelize的文档很晦涩</h3>\n<p>直接看的官网原版文档，晦涩的意思是，新手跟着文档的说明走一遍常常得到错误的结果。我是遇到好几次很莫名的结果，没有时间看源代码，所以就放弃了！</p>\n<h3>bookshelfjs文档更好理解</h3>\n<p>boookshelfjs的文档名单明快多了，至少跟着文档走，都可以走出正确的结果，看看国外用户的活跃度也很高。</p>\n<h3>bookshelfjs基于的knexjs的migration很好用</h3>\n<p>核心还是文档好和活跃度吧，另外感觉ORM对提升效率很重要的，所以分享一下，给正在选择ORM的同学一些启发。有更好的推荐或者意见请留言，O(∩_∩)O~~</p>\n</div>",
            "title": "关于nodejs生态的ORM选择",
            "last_reply_at": "2017-05-26T02:35:23.444Z",
            "good": false,
            "top": false,
            "reply_count": 14,
            "visit_count": 525,
            "create_at": "2017-05-20T15:49:22.442Z",
            "author": {
                "loginname": "nihaoit",
                "avatar_url": "https://avatars0.githubusercontent.com/u/4597527?v=3&s=120"
            }
        },
        {
            "id": "59264f62855efbac2cf7a2f3",
            "author_id": "53159ba53b8795b97303075e",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p><strong>背景</strong>\n现有1000条学生记录，结构如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>{\n\tname:String,&#x2F;&#x2F;名称\n\tclazz:{type:ObjectId,ref:&quot;classes&quot;},&#x2F;&#x2F;班级id\n\tstatus:Number,&#x2F;&#x2F;状态 1在校 2离校\n\tmarks:[Number],&#x2F;&#x2F;标记 1迟到 2早退 3请假\n\tage:Number&#x2F;&#x2F;年龄\n}\n</code></pre><p><strong>需求</strong>\n要求统计1000个学生的所在班级列表，列表内容如下（模拟数据，不要在意统计的合理不合理）：\n班级名称 | 在校人数 | 离校人数 | 没有迟到标记的在校人数 | 没有迟到标记的在校学生的平均年龄</p>\n<p>实现代码：</p>\n<pre class=\"prettyprint\"><code>db.getCollection(&#x27;students&#x27;).aggregate([{\n    $group: {&#x2F;&#x2F;班级分组拿到班级id和班级内的学员信息\n        _id: &quot;$clazz&quot;,\n        stus: {\n            $push: &quot;$$ROOT&quot;\n        }\n    }\n}, {\n    $project: {\n        _id: 1,\n        stus: 1,\n        out_num: {&#x2F;&#x2F;计算离校人员数量\n            $size: {\n                $filter: {\n                    input: &quot;$stus&quot;,\n                    as: &quot;stu&quot;,\n                    cond: { $eq: [&quot;$$stu.status&quot;, 2] }\n                }\n            }\n        },\n        in_num: {&#x2F;&#x2F;计算在校人员数量\n            $size: {\n                $filter: {\n                    input: &quot;$stus&quot;,\n                    as: &quot;stu&quot;,\n                    cond: { $eq: [&quot;$$stu.status&quot;, 1] }\n                }\n            }\n        },\n        in_no_1: {&#x2F;&#x2F;计算 在校并且没有迟到标记的学员列表\n            $filter: {\n                input: &quot;$stus&quot;,\n                as: &quot;stu&quot;,\n                cond: { $and: [{ $eq: [&quot;$$stu.status&quot;, 1] }, { $eq: [{ $indexOfArray: [&quot;$$stu.marks&quot;, 1] }, -1] }] }\n            }\n        },\n    }\n}, {\n    $project: {\n        _id: 1,\n        out_num: 1,\n        in_num: 1,\n        in_no_1: 1,\n        in_nu_1_num: { $size: &quot;$in_no_1&quot; },&#x2F;&#x2F;计算在校并且没有迟到标记的学员数量\n        avg: {&#x2F;&#x2F;计算在校并且没有迟到标记的学员的平均年龄\n            $cond: {\n                if: { $eq: [{ $size: &quot;$in_no_1&quot; }, 0] },&#x2F;&#x2F;如果班级内没有符合条件的学生则年龄记为0\n                then: 0,\n                else: {&#x2F;&#x2F;班级内有符合条件的学生，计算学生年龄总和并除以学生数量\n                    $divide: [{\n                        $reduce: {\n                            input: &quot;$in_no_1&quot;,\n                            initialValue: 0,\n                            in : { $add: [&#x27;$$value&#x27;, &quot;$$this.age&quot;] }\n                        }\n                    }, {\n                        $size: &quot;$in_no_1&quot;\n                    }]\n                }\n            }\n        }\n    }\n}, {\n    $lookup: {&#x2F;&#x2F;关联查询班级信息，关联信息返回为数组\n        from: &quot;classes&quot;,\n        localField: &quot;_id&quot;,\n        foreignField: &quot;_id&quot;,\n        as: &quot;clazz&quot;\n    }\n}, {\n    $unwind: &#x27;$clazz&#x27;&#x2F;&#x2F;拆分班级返回信息数组\n\n}, {\n    $project: {&#x2F;&#x2F;整理最后的数据\n        _id: 1,\n        out_num: 1,\n        in_num: 1,\n        avg: 1,\n        in_nu_1_num: 1,\n        name: &#x27;$clazz.name&#x27;\n    }\n}])\n\n\n</code></pre><p>代码就这些，需要看的是aggregate的各种操作命令（尤其是数组的）。好了笔记就记录这些了。有更好的解决方案，大家一起讨论。</p>\n</div>",
            "title": "使用mongodb的aggregate解决变态需求",
            "last_reply_at": "2017-05-26T02:25:53.621Z",
            "good": false,
            "top": false,
            "reply_count": 2,
            "visit_count": 133,
            "create_at": "2017-05-25T03:28:34.934Z",
            "author": {
                "loginname": "lovemybb",
                "avatar_url": "https://avatars2.githubusercontent.com/u/5569015?v=3&s=120"
            }
        },
        {
            "id": "5718e5685a26c4a841ecbbb6",
            "author_id": "54009f5ccd66f2eb37190485",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><h1>作为一个专业的前端或者全栈工程师，你真的了解HTML head么？</h1>\n<p>下面给出HTML head元素大集合</p>\n<h2>Meta 标签</h2>\n<pre class=\"prettyprint language- html\"><code>&lt;meta charset=&quot;utf-8&quot;&gt;\n&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;\n&lt;meta name=&quot;keywords&quot; content=&quot;your,keywords,here,comma,separated,no,spaces&quot;&gt;\n&lt;meta name=&quot;description&quot; content=&quot;150 words&quot;&gt;\n&lt;meta name=&quot;subject&quot; content=&quot;your website&#x27;s subject&quot;&gt;\n&lt;meta name=&quot;language&quot; content=&quot;en&quot;&gt;\n&lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;&gt;\n&lt;meta name=&quot;revised&quot; content=&quot;Sunday, July 18th, 2010, 5:15 pm&quot;&gt;\n&lt;meta name=&quot;abstract&quot; content=&quot;&quot;&gt;\n&lt;meta name=&quot;topic&quot; content=&quot;&quot;&gt;\n&lt;meta name=&quot;summary&quot; content=&quot;&quot;&gt;\n&lt;meta name=&quot;Classification&quot; content=&quot;Business&quot;&gt;\n&lt;meta name=&quot;author&quot; content=&quot;name, email@example.com&quot;&gt;\n&lt;meta name=&quot;designer&quot; content=&quot;&quot;&gt;\n&lt;meta name=&quot;reply-to&quot; content=&quot;email@example.com&quot;&gt;\n&lt;meta name=&quot;owner&quot; content=&quot;&quot;&gt;\n&lt;meta name=&quot;url&quot; content=&quot;https:&#x2F;&#x2F;example.com&#x2F;&quot;&gt;\n&lt;meta name=&quot;identifier-URL&quot; content=&quot;https:&#x2F;&#x2F;example.com&#x2F;&quot;&gt;\n&lt;meta name=&quot;directory&quot; content=&quot;submission&quot;&gt;\n&lt;meta name=&quot;category&quot; content=&quot;&quot;&gt;\n&lt;meta name=&quot;coverage&quot; content=&quot;Worldwide&quot;&gt;\n&lt;meta name=&quot;distribution&quot; content=&quot;Global&quot;&gt;\n&lt;meta name=&quot;rating&quot; content=&quot;General&quot;&gt;\n&lt;meta name=&quot;revisit-after&quot; content=&quot;7 days&quot;&gt;\n&lt;meta http-equiv=&quot;refresh&quot; content=&quot;300;url=https:&#x2F;&#x2F;example.com&#x2F;&quot;&gt;\n&lt;meta name=&quot;theme-color&quot; content=&quot;#E64545&quot;&gt;\n\n&lt;!-- Cache Control --&gt;\n&lt;meta http-equiv=&quot;Expires&quot; content=&quot;0&quot;&gt;\n&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot;&gt;\n&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-cache&quot;&gt;\n</code></pre><p>是不是都看着熟悉？又叫不准？</p>\n<h2>Link 标签</h2>\n<pre class=\"prettyprint language- html\"><code>&lt;link rel=&quot;copyright&quot; href=&quot;copyright.html&quot;&gt;\n&lt;link rel=&quot;stylesheet&quot; href=&quot;https:&#x2F;&#x2F;example.com&#x2F;styles.css&quot;&gt;\n&lt;link rel=&quot;alternate&quot; href=&quot;https:&#x2F;&#x2F;feeds.feedburner.com&#x2F;martini&quot; type=&quot;application&#x2F;rss+xml&quot; title=&quot;RSS&quot;&gt;\n&lt;link rel=&quot;alternate&quot; href=&quot;https:&#x2F;&#x2F;example.com&#x2F;feed.atom&quot; type=&quot;application&#x2F;atom+xml&quot; title=&quot;Atom 0.3&quot;&gt;\n&lt;link rel=&quot;me&quot; href=&quot;https:&#x2F;&#x2F;google.com&#x2F;profiles&#x2F;thenextweb&quot; type=&quot;text&#x2F;html&quot;&gt;\n&lt;link rel=&quot;archives&quot; href=&quot;https:&#x2F;&#x2F;example.com&#x2F;2003&#x2F;05&#x2F;&quot; title=&quot;May 2003&quot;&gt;\n&lt;link rel=&quot;index&quot; href=&quot;https:&#x2F;&#x2F;example.com&#x2F;&quot; title=&quot;DeWitt Clinton&quot;&gt;\n&lt;link rel=&quot;start&quot; href=&quot;https:&#x2F;&#x2F;example.com&#x2F;photos&#x2F;pattern_recognition_1_about&#x2F;&quot; title=&quot;Pattern Recognition 1&quot;&gt;\n&lt;link rel=&quot;prev&quot; href=&quot;https:&#x2F;&#x2F;example.com&#x2F;opensearch&#x2F;opensearch-and-openid-a-sure-way-to-get-my-attention&#x2F;&quot; title=&quot;OpenSearch and OpenID? A sure way to get my attention.&quot;&gt;\n&lt;link rel=&quot;search&quot; href=&quot;&#x2F;search.xml&quot; type=&quot;application&#x2F;opensearchdescription+xml&quot; title=&quot;Viatropos&quot;&gt;\n&lt;link rel=&quot;self&quot; type=&quot;application&#x2F;atom+xml&quot; href=&quot;https:&#x2F;&#x2F;example.com&#x2F;atomFeed.php?page=3&quot;&gt;\n&lt;link rel=&quot;first&quot; href=&quot;https:&#x2F;&#x2F;example.com&#x2F;atomFeed.php&quot;&gt;\n&lt;link rel=&quot;next&quot; href=&quot;https:&#x2F;&#x2F;example.com&#x2F;atomFeed.php?page=4&quot;&gt;\n&lt;link rel=&quot;previous&quot; href=&quot;https:&#x2F;&#x2F;example.com&#x2F;atomFeed.php?page=2&quot;&gt;\n&lt;link rel=&quot;last&quot; href=&quot;https:&#x2F;&#x2F;example.com&#x2F;atomFeed.php?page=147&quot;&gt;\n&lt;link rel=&quot;shortlink&quot; href=&quot;https:&#x2F;&#x2F;example.com&#x2F;?p=43625&quot;&gt;\n&lt;link rel=&quot;canonical&quot; href=&quot;https:&#x2F;&#x2F;example.com&#x2F;2010&#x2F;06&#x2F;9-things-to-do-before-entering-social-media.html&quot;&gt;\n&lt;link rel=&quot;EditURI&quot; href=&quot;https:&#x2F;&#x2F;example.com&#x2F;xmlrpc.php?rsd&quot; type=&quot;application&#x2F;rsd+xml&quot; title=&quot;RSD&quot;&gt;\n&lt;link rel=&quot;pingback&quot; href=&quot;https:&#x2F;&#x2F;example.com&#x2F;xmlrpc.php&quot;&gt;\n&lt;link rel=&quot;manifest&quot; href=&quot;manifest.json&quot;&gt;\n\n</code></pre><p>里面restful api写法还是。。。。学吧</p>\n<h3>Favicons</h3>\n<pre class=\"prettyprint language- html\"><code>&lt;!-- For IE 10 and below --&gt;  \n&lt;!-- No link, just place a file called favicon.ico in the root directory --&gt;\n\n&lt;!-- For IE 11, Chrome, Firefox, Safari, Opera --&gt;  \n&lt;link rel=&quot;icon&quot; href=&quot;path&#x2F;to&#x2F;favicon-16.png&quot; sizes=&quot;16x16&quot; type=&quot;image&#x2F;png&quot;&gt;  \n&lt;link rel=&quot;icon&quot; href=&quot;path&#x2F;to&#x2F;favicon-32.png&quot; sizes=&quot;32x32&quot; type=&quot;image&#x2F;png&quot;&gt;  \n&lt;link rel=&quot;icon&quot; href=&quot;path&#x2F;to&#x2F;favicon-48.png&quot; sizes=&quot;48x48&quot; type=&quot;image&#x2F;png&quot;&gt;  \n&lt;link rel=&quot;icon&quot; href=&quot;path&#x2F;to&#x2F;favicon-62.png&quot; sizes=&quot;62x62&quot; type=&quot;image&#x2F;png&quot;&gt;\n&lt;!-- More info: https:&#x2F;&#x2F;bitsofco.de&#x2F;all-about-favicons-and-touch-icons&#x2F; --&gt;\n</code></pre><p><a href=\"https://bitsofco.de/all-about-favicons-and-touch-icons/\">All About Favicons (And Touch Icons)</a></p>\n<h2>社交</h2>\n<h3>Facebook / Open Graph</h3>\n<pre class=\"prettyprint language- html\"><code>&lt;meta property=&quot;og:url&quot; content=&quot;https:&#x2F;&#x2F;www.example.com&#x2F;&quot;&gt;\n&lt;meta property=&quot;og:title&quot; content=&quot;Content Title&quot;&gt;\n&lt;meta property=&quot;og:description&quot; content=&quot;Description Here&quot;&gt;\n&lt;meta property=&quot;og:site_name&quot; content=&quot;Site Name&quot;&gt;\n&lt;meta property=&quot;og:image&quot; content=&quot;https:&#x2F;&#x2F;example.com&#x2F;image.jpg&quot;&gt;\n&lt;meta property=&quot;og:type&quot; content=&quot;website&quot;&gt;\n&lt;meta property=&quot;og:locale&quot; content=&quot;en_US&quot;&gt;\n&lt;meta property=&quot;fb:app_id&quot; content=&quot;Facebook numeric ID&quot;&gt;\n&lt;meta property=&quot;fb:admins&quot; content=&quot;Facebook numeric ID&quot;&gt;\n&lt;!-- Facebook: https:&#x2F;&#x2F;developers.facebook.com&#x2F;docs&#x2F;sharing&#x2F;webmasters#markup --&gt;\n&lt;!-- Open Graph: http:&#x2F;&#x2F;ogp.me&#x2F; --&gt;\n</code></pre><p><a href=\"https://developers.facebook.com/docs/sharing/webmasters#markup\">Facebook Open Graph Markup</a>\n<a href=\"http://ogp.me/\">Open Graph protocol</a></p>\n<p>这个基本没用，看看热闹</p>\n<h3>Twitter</h3>\n<pre class=\"prettyprint language- html\"><code>&lt;meta name=&quot;twitter:card&quot; content=&quot;summary_large_image&quot;&gt;\n&lt;meta name=&quot;twitter:site&quot; content=&quot;@publisher_handle&quot;&gt;\n&lt;meta name=&quot;twitter:creator&quot; content=&quot;@author_handle&quot;&gt;\n&lt;meta name=&quot;twitter:title&quot; content=&quot;Content Title&quot;&gt;\n&lt;meta name=&quot;twitter:description&quot; content=&quot;Content description less than 200 characters&quot;&gt;\n&lt;meta name=&quot;twitter:image&quot; content=&quot;https:&#x2F;&#x2F;example.com&#x2F;image.jpg&quot;&gt;\n&lt;!-- Twitter summary card with large image must be at least 280x150px --&gt;\n&lt;!-- More info: https:&#x2F;&#x2F;dev.twitter.com&#x2F;cards&#x2F;getting-started --&gt;\n&lt;!-- Validate: https:&#x2F;&#x2F;dev.twitter.com&#x2F;docs&#x2F;cards&#x2F;validation&#x2F;validator --&gt;\n</code></pre><p><a href=\"https://dev.twitter.com/cards/getting-started\">Twitter Cards: Getting Started Guide</a>\n<a href=\"https://dev.twitter.com/docs/cards/validation/validator\">Twitter Card Validator</a></p>\n<p>这个基本没用，看看热闹</p>\n<h3>Google+ / <a href=\"http://Schema.org\">Schema.org</a></h3>\n<pre class=\"prettyprint language- html\"><code>&lt;meta itemprop=&quot;name&quot; content=&quot;Content Title&quot;&gt;\n&lt;meta itemprop=&quot;description&quot; content=&quot;Content description less than 200 characters&quot;&gt;\n&lt;meta itemprop=&quot;image&quot; content=&quot;https:&#x2F;&#x2F;example.com&#x2F;image.jpg&quot;&gt;\n</code></pre><p>这个基本没用，看看热闹</p>\n<h2>浏览器/平台</h2>\n<h4>苹果 iOS 标签</h4>\n<p>hybrid必备</p>\n<pre class=\"prettyprint language- html\"><code>&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;\n&lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;My App&quot;&gt;\n&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt;\n&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt;\n&lt;meta name=&quot;apple-touch-fullscreen&quot; content=&quot;yes&quot;&gt;\n&lt;link rel=&quot;apple-touch-icon&quot; href=&quot;apple-touch-icon.png&quot;&gt;\n&lt;link rel=&quot;apple-touch-icon-precomposed&quot; href=&quot;apple-touch-icon-precomposed.png&quot;&gt;\n&lt;link rel=&quot;apple-touch-startup-image&quot; href=&quot;startup.png&quot;&gt;\n&lt;!-- More info: https:&#x2F;&#x2F;developer.apple.com&#x2F;safari&#x2F;library&#x2F;documentation&#x2F;appleapplications&#x2F;reference&#x2F;safarihtmlref&#x2F;articles&#x2F;metatags.html --&gt;\n</code></pre><p><a href=\"https://developer.apple.com/safari/library/documentation/appleapplications/reference/safarihtmlref/articles/metatags.html\">Apple Meta Tags</a></p>\n<h4>Internet Explorer Meta Tags</h4>\n<pre class=\"prettyprint language- html\"><code>&lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;ie=edge&quot;&gt;\n&lt;meta http-equiv=&quot;cleartype&quot; content=&quot;on&quot;&gt;\n\n&lt;!-- Pinned Site --&gt;\n&lt;!-- IE 10 &#x2F; Windows 8 --&gt;\n&lt;meta name=&quot;msapplication-TileImage&quot; content=&quot;pinned-tile-144.png&quot;&gt;  \n&lt;meta name=&quot;msapplication-TileColor&quot; content=&quot;#009900&quot;&gt;\n&lt;!-- IE 11 &#x2F; Windows 9.1 --&gt;\n&lt;meta name=&quot;msapplication-config&quot; content=&quot;ieconfig.xml&quot;&gt;\n</code></pre><h4>Internet Explorer Meta 标签 (历史遗留，不要用)</h4>\n<pre class=\"prettyprint language- html\"><code>&lt;!-- Legacy Tags (DO NOT USE) --&gt;\n&lt;meta name=&quot;mssmarttagspreventparsing&quot; content=&quot;true&quot;&gt;\n&lt;meta http-equiv=&quot;page-enter&quot; content=&quot;revealtrans(duration=2,transition=2)&quot;&gt;\n&lt;meta http-equiv=&quot;page-exit&quot; content=&quot;revealtrans(duration=3,transition=12)&quot;&gt;\n</code></pre><h5>Safari 9: Pinned tabs in El Capitan</h5>\n<pre class=\"prettyprint language-html\"><code>&lt;link rel=&quot;mask-icon&quot; href=&quot;icon.svg&quot; color=&quot;red&quot;&gt;\n</code></pre><h2>其他资源</h2>\n<ul>\n<li><a href=\"https://github.com/joshbuchea/HEAD\">原文</a></li>\n<li><a href=\"https://github.com/h5bp/html5-boilerplate/blob/master/dist/doc/html.md\">HTML5 Boilerplate Docs: The HTML</a></li>\n</ul>\n<h2>最后</h2>\n<p>只放大招，剩下的自己去补习吧，知不足，方为进步之动力，加油！</p>\n<p>全文完</p>\n<p>欢迎关注我的公众号【node全栈】</p>\n<p><img src=\"//dn-cnode.qbox.me/FtALxsauUkYDGdzcuA5y6BaIdUMC\" alt=\"node全栈.png\"></p>\n<p>如果想参与评论，请点击原文链接，进入国内最专业的cnode论坛</p>\n<p>联系我，更多交流</p>\n<p><img src=\"//dn-cnode.qbox.me/FrCbjyzuNmHF1u3j8t26t-cGWPnB\" alt=\"xiaoweiquan.jpeg\"></p>\n</div>",
            "title": "作为一个专业的前端或者全栈工程师，你真的了解HTML head么？",
            "last_reply_at": "2017-05-26T02:22:44.295Z",
            "good": true,
            "top": false,
            "reply_count": 17,
            "visit_count": 4012,
            "create_at": "2016-04-21T14:36:24.494Z",
            "author": {
                "loginname": "i5ting",
                "avatar_url": "https://avatars0.githubusercontent.com/u/3118295?v=3&s=120"
            }
        },
        {
            "id": "51d249dcd44cbfa3040bd28a",
            "author_id": "518af92e63e9f8a54230929a",
            "content": "<div class=\"markdown-text\"><p>var mongoose = require(‘mongoose’);\nvar Grid = require(‘gridfs-stream’);\nvar async = require(‘async’);\nvar gfs = Grid(mongoose.connection.db, mongoose.mongo);\nvar GridFile = require(’…/…/models/gridfs’).GridFile;</p>\n<p>var put_save = function(req, res) {\nvar fnames = util.isArray(req.files.fname) ? req.files.fname : [req.files.fname];\nasync.map(fnames, process_file, function(err, results) {\nres.json({\n‘err’: err,\n‘results’: results\n})\n})</p>\n<pre class=\"prettyprint\"><code>function process_file(fname, callback) {\n    var gfs_options = {\n        filename: fname.name,\n        mode: &#x27;w&#x27;,\n        content_type: fname.type,\n        metadata: {\n            &#x27;client&#x27;: req.user.client.id,\n            &#x27;user&#x27;: req.user.id\n        }\n    };\n    var writestream = gfs.createWriteStream(gfs_options);\n    fs.createReadStream(fname.path).pipe(writestream);\n    writestream.on(&#x27;close&#x27;, function(file) {\n        fs.unlink(fname.path, function(err) {\n            if (err) {\n                return callback(err, null);\n            };\n            callback(null, file)\n        });\n    });\n\n}\n</code></pre><p>}</p>\n</div>",
            "title": "应用gridfs-stream模块上传图片到mongodb数据库",
            "last_reply_at": "2017-05-26T01:34:44.960Z",
            "good": false,
            "top": false,
            "reply_count": 2,
            "visit_count": 5358,
            "create_at": "2013-07-02T03:32:44.825Z",
            "author": {
                "loginname": "banther",
                "avatar_url": "//gravatar.com/avatar/8910b4646b5edbf90e8661efb5eeda88?size=48"
            }
        },
        {
            "id": "5924f966d371b6372a8afcf1",
            "author_id": "59200934ba8670562a40f2fe",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>通过 process.memoryUsage();可以获取nodejs堆内存使用情况。\n获取的几个变量分别为，\nrss是Resident Set Size的缩写，为常驻内存的总大小\nheapTotal是V8为堆分配的总大小\nheapUsed是已使用的堆大小。\nexternal是程序使用V8外部的内存。</p>\n<p>关于内存问题是否只要heapUsed稳定则，表示没内存泄漏问题？</p>\n</div>",
            "title": "关于nodejs内存的一些问题。",
            "last_reply_at": "2017-05-26T01:30:57.980Z",
            "good": false,
            "top": false,
            "reply_count": 6,
            "visit_count": 162,
            "create_at": "2017-05-24T03:09:26.500Z",
            "author": {
                "loginname": "bingino",
                "avatar_url": "https://avatars2.githubusercontent.com/u/14208659?v=3&s=120"
            }
        },
        {
            "id": "56d6585de3889756776c7e75",
            "author_id": "541be4cbad60405c1f02826c",
            "tab": "job",
            "content": "<div class=\"markdown-text\"><h4>我们是一家</h4>\n<p>全国性保险经纪代理机构＋互联网科技公司。\n目标：公司正在打造互联网+的保险经纪平台，我们要在五年内创造100亿的保费规模。\n公司目前位于<strong>浦东金桥（中环内）</strong></p>\n<h4>我们能提供的</h4>\n<p>1、准上市企业，可提供丰富的培训机会及广阔的发展空间；\n2、工作时间：5天工作制、每天工作7.5小时，1小时弹性时间；\n3、社会保险：（养老、失业、工伤、生育、医疗保险+重大疾病）、额外补充意外保险；\n4、享受餐补、电脑补贴；\n5、法定带薪假期；\n6、员工活动：每周免费羽毛球员工活动、年度旅游、团队建设、拓展训练；\n7、慰问类别：春节、端午、中秋、结婚、生育、病期、丧礼等；\n8、多种培训：计算机技术、心理管理、项目管理等；</p>\n<h4>我们需要NodeJS工程师</h4>\n<p><strong>岗位职责</strong></p>\n<ul>\n<li>负责后台系统代码开发、维护</li>\n<li>参与运营系统、产品销售系统业务分析和设计</li>\n</ul>\n<p><strong>岗位要求</strong></p>\n<ul>\n<li>熟练掌握Node.js、java、sql，具有良好的编程习惯</li>\n<li>熟悉MongoDB、Mysql、redis</li>\n<li>熟练使用Git</li>\n<li>熟练阅读英文文档</li>\n<li>喜欢学习，具有良好的沟通技能、协作能力</li>\n</ul>\n<p><strong>我们更期望您能</strong></p>\n<ul>\n<li>熟练掌握几个NodeJS框架，Express、koa、kraken…</li>\n<li>熟悉Linux，熟练掌握shell常用命令</li>\n<li>熟悉web service、REST、Data Log、Zookeeper、Kafka…</li>\n</ul>\n<p><strong>我们也需要前端开发工程师</strong></p>\n<ul>\n<li>熟悉前端技术：html5、css、JavaScript、AngularJS、Grunt、Bower…</li>\n</ul>\n<p><strong>联系方式</strong>\n朱先生，hr@99bx.cn\nPS. 欢迎优秀的应届毕业生或实习生</p>\n<p><strong><em>公司最新动态</em></strong></p>\n<ol>\n<li>8月份公司拿到全国范围保险业务经营牌照，完成增资5000万。</li>\n<li>9月份在武汉顺利召开全国业务启动大会，新开广州、深圳、合肥和上海四个分支机构</li>\n<li>确定将在16年12月完成新三板挂牌。</li>\n</ol>\n</div>",
            "title": "[上海] 慧保科技 [15K-30K  + 年终奖 + 期权] 诚聘 NodeJS工程师",
            "last_reply_at": "2017-05-26T01:27:42.787Z",
            "good": false,
            "top": false,
            "reply_count": 20,
            "visit_count": 2502,
            "create_at": "2016-03-02T03:05:01.877Z",
            "author": {
                "loginname": "coopping",
                "avatar_url": "https://avatars.githubusercontent.com/u/8099034?v=3&s=120"
            }
        },
        {
            "id": "58e76f0ba8de682605f3752c",
            "author_id": "58d5fcf06f8b9bf02d1d0ac3",
            "tab": "job",
            "content": "<div class=\"markdown-text\"><p>坐标：北京朝阳北街吉庆里14号佳汇国际中心A座1503\n职位：运维工程师 4 名\n-负责网络架构、服务器集群部署、配置管理等运维平台技术架构的方案设计和实施\n-把握整体运维平台的设计和技术决策, 指导系统实施和部署</p>\n<p>关于况客\n况客是一家在金融领域领先的科技互联网公司，主要产品包括 “投研系统解决方案”、“FOF投资管理系统”。获得2项专利，3项软著证书。“况客”致力于为国内公募基金、证券公司、银行、保险公司及私募基金等金融机构提供新一代的投资研究解决方案。已经进入第三轮融资5000万，市值1.67亿估值，并已获得中关村高新企业证书。</p>\n<p>关于职位\n因为业务快速发展，我们诚挚邀请运维工程师加盟 ，一些要求如下：\n能力要求：\n1、计算机相关专业, 本科及以上学历, 1年以上工作经验\n2、熟悉AWS、阿里云等云主机服务\n3、擅长Linux系统管理及常见应用部署维护, 熟练使用一种编程语言完成自动化脚本\n4、了解分步式系统, 精于容量规划、架构设计、性能优化\n5、熟悉容器虚拟化技术 Docker，掌握基本的数据库管理MySQL, MongoDB, Redis\n6、对工作有激情、执行力强，能够承受高强度工作压力\n7、能力突出者可不局限于以上规定</p>\n<p>基本要求：（应届生）\n1、熟练使用shell\n2、熟练使用*nix系统\n3、熟练使用常用数据库\n4、熟悉网络协议、拓扑、安全等基础知识</p>\n<p>加分项：\n1、会使用其他一种或多种编程语言\n2、熟悉常用监控软件\n3、熟悉docker、分布式计算或存储系统\n4、学习能力强、逻辑思维好、有钻研和探索精神\n5、其他优点或者某些成就</p>\n<p>备注：应届和社招均可</p>\n<p>我们注重能力包括：\n1、解决问题能力。自信，上进，积极主动，目标导向。\n2、学习能力。善于学习，乐于分享，渴望每天都在进步。\n3、团队协作能力。诚实，坦率，有责任心，信任、尊重、包容。</p>\n<p>况客的优势</p>\n<p>1、丰厚的薪酬回报\n初中级职位 6~15k，高级职位 15~30k，上不封顶，13薪，年底还可能有丰厚的绩效奖金。目前公司处于快速发展阶段，公司商业模式确定，营收稳健，并且已有顶尖美元风投基金加入，前景可期。我们将把你视为伙伴，希望通过一起努力，能够提供超出你预期的回报。</p>\n<p>2、宽阔的成长空间\n况客很推崇技术跨界，乐见你成长为技术专家，全栈工程师，产品经理或者增长黑客。\n良好的工作氛围，舒适的工作环境\n况客的技术团队技术研究和讨论氛围很热烈。公司的办公室宽敞开放，我们尽可能为您提供</p>\n<p>3、舒适的工作环境。\n联系方式\n如果您对我们的工作职位感兴趣，请把您的简历或情况发邮件到 <a href=\"mailto:hr@qutke.com\">hr@qutke.com</a></p>\n</div>",
            "title": "【况客】诚聘运维工程师",
            "last_reply_at": "2017-05-26T01:23:48.669Z",
            "good": false,
            "top": false,
            "reply_count": 16,
            "visit_count": 299,
            "create_at": "2017-04-07T10:50:51.129Z",
            "author": {
                "loginname": "qutker",
                "avatar_url": "https://avatars1.githubusercontent.com/u/26649565?v=3&s=120"
            }
        },
        {
            "id": "592781a8ba8670562a40f51d",
            "author_id": "59200934ba8670562a40f2fe",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>通过  process.memoryUsage() 获取nodejs内存使用情况，且每隔45S就会进行一个强制gc() 。\n经过一晚上测试，发现headUsed和heapTotal变化都不大，但rss增长幅度比较大。这是因为内存泄漏还是nodejs和linux自身回收内存的机制所致。希望有经验的朋友能予以解答。谢谢。</p>\n<p>最初的内存占用情况</p>\n<blockquote></blockquote>\n<p>[2017-05-25 20:24:03.701] [WARN] log_file - wss.client5000\n[2017-05-25 20:24:03.701] [WARN] log_file - client5000\n[2017-05-25 20:24:03.701] [WARN] log_file - loginMap0\n[2017-05-25 20:24:03.701] [WARN] log_file - timerMap5000\n[2017-05-25 20:24:03.701] [WARN] log_file - { rss: 86278144,\nheapTotal: 65048576,\nheapUsed: 51594504,\nexternal: 919812 }\n[2017-05-25 20:24:48.809] [WARN] log_file - wss.client5000\n[2017-05-25 20:24:48.809] [WARN] log_file - client5000\n[2017-05-25 20:24:48.809] [WARN] log_file - loginMap0\n[2017-05-25 20:24:48.809] [WARN] log_file - timerMap5000\n[2017-05-25 20:24:48.809] [WARN] log_file - { rss: 86786048,\nheapTotal: 64000000,\nheapUsed: 51709264,\nexternal: 978224 }\n[2017-05-25 20:25:33.957] [WARN] log_file - wss.client5000\n[2017-05-25 20:25:33.957] [WARN] log_file - client5000\n[2017-05-25 20:25:33.957] [WARN] log_file - loginMap0\n[2017-05-25 20:25:33.957] [WARN] log_file - timerMap5000\n[2017-05-25 20:25:33.958] [WARN] log_file - { rss: 85770240,\nheapTotal: 64000000,\nheapUsed: 51306016,\nexternal: 898460 }\n[2017-05-25 20:26:19.054] [WARN] log_file - wss.client5000\n[2017-05-25 20:26:19.054] [WARN] log_file - client5000\n[2017-05-25 20:26:19.054] [WARN] log_file - loginMap0\n[2017-05-25 20:26:19.054] [WARN] log_file - timerMap5000\n[2017-05-25 20:26:19.054] [WARN] log_file - { rss: 84819968,\nheapTotal: 62951424,\nheapUsed: 51305040,\nexternal: 898460 }</p>\n<blockquote></blockquote>\n<p>经过一晚上的发送消息之后的情况。</p>\n<blockquote></blockquote>\n<p>[2017-05-26 09:07:26.252] [WARN] log_file - wss.client5000\n[2017-05-26 09:07:26.253] [WARN] log_file - client5000\n[2017-05-26 09:07:26.253] [WARN] log_file - loginMap0\n[2017-05-26 09:07:26.253] [WARN] log_file - timerMap5000\n[2017-05-26 09:07:26.253] [WARN] log_file - { rss: 101851136,\nheapTotal: 66097152,\nheapUsed: 51416176,\nexternal: 742988 }\n[2017-05-26 09:08:11.347] [WARN] log_file - wss.client5000\n[2017-05-26 09:08:11.348] [WARN] log_file - client5000\n[2017-05-26 09:08:11.348] [WARN] log_file - loginMap0\n[2017-05-26 09:08:11.348] [WARN] log_file - timerMap5000\n[2017-05-26 09:08:11.348] [WARN] log_file - { rss: 101851136,\nheapTotal: 66097152,\nheapUsed: 51416176,\nexternal: 742988 }\n[2017-05-26 09:08:56.490] [WARN] log_file - wss.client5000\n[2017-05-26 09:08:56.490] [WARN] log_file - client5000\n[2017-05-26 09:08:56.490] [WARN] log_file - loginMap0\n[2017-05-26 09:08:56.490] [WARN] log_file - timerMap5000\n[2017-05-26 09:08:56.490] [WARN] log_file - { rss: 101851136,\nheapTotal: 66097152,\nheapUsed: 51416176,\nexternal: 742988 }\n[2017-05-26 09:09:41.614] [WARN] log_file - wss.client5000\n[2017-05-26 09:09:41.614] [WARN] log_file - client5000\n[2017-05-26 09:09:41.614] [WARN] log_file - loginMap0\n[2017-05-26 09:09:41.614] [WARN] log_file - timerMap5000\n[2017-05-26 09:09:41.614] [WARN] log_file - { rss: 101851136,\nheapTotal: 66097152,\nheapUsed: 51416176,\nexternal: 742988 }\n[2017-05-26 09:10:26.762] [WARN] log_file - wss.client5000\n[2017-05-26 09:10:26.763] [WARN] log_file - client5000\n[2017-05-26 09:10:26.763] [WARN] log_file - loginMap0\n[2017-05-26 09:10:26.763] [WARN] log_file - timerMap5000\n[2017-05-26 09:10:26.763] [WARN] log_file - { rss: 101851136,\nheapTotal: 66097152,\nheapUsed: 51416176,\nexternal: 742988 }</p>\n<blockquote></blockquote>\n</div>",
            "title": "关于nodejs内存泄漏问题的疑问？",
            "last_reply_at": "2017-05-26T01:15:20.695Z",
            "good": false,
            "top": false,
            "reply_count": 0,
            "visit_count": 44,
            "create_at": "2017-05-26T01:15:20.695Z",
            "author": {
                "loginname": "bingino",
                "avatar_url": "https://avatars2.githubusercontent.com/u/14208659?v=3&s=120"
            }
        },
        {
            "id": "581b0c4ebb9452c9052e7acb",
            "author_id": "5110f2bedf9e9fcc584e4677",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>GitHub: <a href=\"https://github.com/nswbmw/N-blog\">https://github.com/nswbmw/N-blog</a></p>\n<h2>目录</h2>\n<ul>\n<li>开发环境搭建\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/1.1%20Node.js%20%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8.md\">Node.js 的安装与使用</a>\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/1.1%20Node.js%20%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8.md#111-%E5%AE%89%E8%A3%85-nodejs\">安装 Node.js</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/1.1%20Node.js%20%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8.md#112-n-%E5%92%8C-nvm\">n 和 nvm</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/1.1%20Node.js%20%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8.md#113-nrm\">nrm</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/1.2%20MongoDB%20%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8.md\">MongoDB 的安装与使用</a>\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/1.2%20MongoDB%20%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8.md#121-%E5%AE%89%E8%A3%85%E4%B8%8E%E5%90%AF%E5%8A%A8-mongodb\">安装与启动 MongoDB</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/1.2%20MongoDB%20%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8.md#122-robomongo-%E5%92%8C-mongochef\">Robomongo 和 MongoChef</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Node.js 知识点讲解\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/2.1%20require.md\">require</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/2.2%20exports%20%E5%92%8C%20module.exports.md\">exports 和 module.exports</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/2.3%20Promise.md\">Promise</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/2.4%20%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.md\">环境变量</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/2.5%20package.json.md\">packge.json</a>\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/2.5%20package.json.md#251-semver\">semver</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/2.6%20npm%20%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.md\">npm 使用注意事项</a>\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/2.6%20npm%20%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.md#261-npm-init\">npm init</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/2.6%20npm%20%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.md#262-npm-install\">npm install</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/2.6%20npm%20%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.md#263-npm-scripts\">npm scripts</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/2.6%20npm%20%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.md#264-npm-shrinkwrap\">npm shrinkwrap </a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Hello, Express\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/3.1%20%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E4%B8%AA%20Express%20%E9%A1%B9%E7%9B%AE.md\">初始化一个 Express 项目</a>\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/3.1%20%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E4%B8%AA%20Express%20%E9%A1%B9%E7%9B%AE.md#311-supervisor\">supervisor</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/3.2%20%E8%B7%AF%E7%94%B1.md\">路由</a>\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/3.2%20%E8%B7%AF%E7%94%B1.md#321-expressrouter\">express.Router</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/3.3%20%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E.md\">模板引擎</a>\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/3.3%20%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E.md#331-ejs\">ejs</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/3.3%20%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E.md#332-includes\">includes</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/3.4%20Express%20%E6%B5%85%E6%9E%90.md\">Express 浅析</a>\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/3.4%20Express%20%E6%B5%85%E6%9E%90.md#341-%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E-next\">中间件与 next</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/3.4%20Express%20%E6%B5%85%E6%9E%90.md#342-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86\">错误处理</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>一个简单的博客\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.1%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.md\">开发环境</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.2%20%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C.md\">准备工作</a>\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.2%20%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C.md#421-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84\">目录结构</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.2%20%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C.md#422-%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E6%A8%A1%E5%9D%97\">安装依赖模块</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.3%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.md\">配置文件</a>\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.3%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.md#431-config-lite\">config-lite</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.4%20%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1.md\">功能设计</a>\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.4%20%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1.md#441-%E5%8A%9F%E8%83%BD%E4%B8%8E%E8%B7%AF%E7%94%B1%E8%AE%BE%E8%AE%A1\">功能与路由设计</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.4%20%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1.md#442-%E4%BC%9A%E8%AF%9D\">会话</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.4%20%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1.md#443-%E9%A1%B5%E9%9D%A2%E9%80%9A%E7%9F%A5\">页面通知</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.4%20%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1.md#444-%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6\">权限控制</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.5%20%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1.md\">页面设计</a>\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.5%20%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1.md#451-%E7%BB%84%E4%BB%B6\">组件</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.5%20%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1.md#452-applocals-%E5%92%8C-reslocals\">app.locals 和 res.locals</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.6%20%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93.md\">连接数据库</a>\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.6%20%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93.md#461-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-mongolass\">为什么使用 Mongolass</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.7%20%E6%B3%A8%E5%86%8C.md\">注册</a>\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.7%20%E6%B3%A8%E5%86%8C.md#471-%E7%94%A8%E6%88%B7%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1\">用户模型设计</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.7%20%E6%B3%A8%E5%86%8C.md#472-%E6%B3%A8%E5%86%8C%E9%A1%B5\">注册页</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.7%20%E6%B3%A8%E5%86%8C.md#473-%E6%B3%A8%E5%86%8C%E4%B8%8E%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0\">注册与文件上传</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.8%20%E7%99%BB%E5%87%BA%E4%B8%8E%E7%99%BB%E5%BD%95.md\">登出与登录</a>\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.8%20%E7%99%BB%E5%87%BA%E4%B8%8E%E7%99%BB%E5%BD%95.md#481-%E7%99%BB%E5%87%BA\">登出</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.8%20%E7%99%BB%E5%87%BA%E4%B8%8E%E7%99%BB%E5%BD%95.md#482-%E7%99%BB%E5%BD%95%E9%A1%B5\">登录页</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.8%20%E7%99%BB%E5%87%BA%E4%B8%8E%E7%99%BB%E5%BD%95.md#483-%E7%99%BB%E5%BD%95\">登录</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.9%20%E6%96%87%E7%AB%A0.md\">文章</a>\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.9%20%E6%96%87%E7%AB%A0.md#491-%E6%96%87%E7%AB%A0%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1\">文章模型设计</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.9%20%E6%96%87%E7%AB%A0.md#492-%E5%8F%91%E8%A1%A8%E6%96%87%E7%AB%A0\">发表文章</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.9%20%E6%96%87%E7%AB%A0.md#493-%E4%B8%BB%E9%A1%B5%E4%B8%8E%E6%96%87%E7%AB%A0%E9%A1%B5\">主页与文章页</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.9%20%E6%96%87%E7%AB%A0.md#494-%E7%BC%96%E8%BE%91%E4%B8%8E%E5%88%A0%E9%99%A4%E6%96%87%E7%AB%A0\">编辑与删除文章</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.10%20%E7%95%99%E8%A8%80.md\">留言</a>\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.10%20%E7%95%99%E8%A8%80.md#4101-%E7%95%99%E8%A8%80%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1\">留言模型设计</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.10%20%E7%95%99%E8%A8%80.md#4102-%E6%98%BE%E7%A4%BA%E7%95%99%E8%A8%80\">显示留言</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.10%20%E7%95%99%E8%A8%80.md#4103-%E5%8F%91%E8%A1%A8%E4%B8%8E%E5%88%A0%E9%99%A4%E7%95%99%E8%A8%80\">发表与删除留言</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.11%20404%20%E9%A1%B5%E9%9D%A2.md\">404页面</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.12%20%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2.md\">错误页面</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.13%20%E6%97%A5%E5%BF%97.md\">日志</a>\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.13%20%E6%97%A5%E5%BF%97.md#4131-winston-%E5%92%8C-express-winston\">winston 和 express-winston</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.13%20%E6%97%A5%E5%BF%97.md#4132-gitignore\">.gitignore</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.14%20%E6%B5%8B%E8%AF%95.md\">测试</a>\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.14%20%E6%B5%8B%E8%AF%95.md#4141-mocha-%E5%92%8C-supertest\">mocha 和 supertest</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.14%20%E6%B5%8B%E8%AF%95.md#4142-%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87\">测试覆盖率</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.15%20%E9%83%A8%E7%BD%B2.md\">部署</a>\n<ul>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.15%20%E9%83%A8%E7%BD%B2.md#4151-%E7%94%B3%E8%AF%B7-mlab\">申请 MLab</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.15%20%E9%83%A8%E7%BD%B2.md#4152-pm2\">pm2</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.15%20%E9%83%A8%E7%BD%B2.md#4152-%E9%83%A8%E7%BD%B2%E5%88%B0-heroku\">部署到 Heroku</a></li>\n<li><a href=\"https://github.com/nswbmw/N-blog/blob/master/book/4.15%20%E9%83%A8%E7%BD%B2.md#4153-%E9%83%A8%E7%BD%B2%E5%88%B0-ucloud\">部署到 UCloud</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>",
            "title": "《一起学 Node.js》彻底重写完毕",
            "last_reply_at": "2017-05-26T01:07:31.912Z",
            "good": false,
            "top": false,
            "reply_count": 305,
            "visit_count": 101879,
            "create_at": "2016-11-03T10:07:10.155Z",
            "author": {
                "loginname": "nswbmw",
                "avatar_url": "https://avatars3.githubusercontent.com/u/4279697?v=3&s=120"
            }
        },
        {
            "id": "5926c783d371b6372a8afdc6",
            "author_id": "5833fc186add41f206000ad4",
            "tab": "job",
            "content": "<div class=\"markdown-text\"><p>IMPLUS 是个创业公司，\n你需要贡献代码，我知道这是你的最爱😝\n但我们更需要你，参与到业务、参与到公司发展，勇敢说出你的想法，\n我们更需要你，努力学习，拓展视野，快速成长；\n我们更需要你知道，你不只是一个 developer，而是一个 partner ！💪\n所以，我们期待：\n积极、谦逊、成熟、热爱技术，不断突破的你</p>\n<p>我们是做什么的\n我们致力于建立自动化流量购买和媒介投放系统，帮助全球广告主高效地获取高质量有价值的全球用户。</p>\n<p>我们的产品\nIMPLUS 自主研发的智能广告系统能自动化地完成全球流量购买，并利用核心的流量匹配技术高效地将全球流量价值最大化。系统能有效识别用户的行为、设备、运营商、浏览器及其他更多属性，精准地为广告商提供最优的广告解决方案。</p>\n<p>你身边的伙伴\n超 nice 的新加坡 leader，不讲笑话不讲技术似乎活不了的程序猿，边笑边吐槽的业务媛😄\n国际团队，所以你英文要👌哦</p>\n<p>我们的文化\nHappy 💗扁平化的团队，弹性自由的工作，贴心的糕点，每月的生日 Par 和团建，有 Heart,有你~\nEnjoy💗 工作遇到难题，有挫折？有压力？找伙伴吧！超友善可爱的团队，尽管说出来，一起分担， 一起更快乐的工作~\nCare💗 朋友嘛，互相关心才是朋友嘛~</p>\n<p>苦苦寻觅的人才：\n中高级全栈开发 20-40K\n你会 Go, node.js, 也会 angular.js ？请你一定要快来！！！\n还对算法和机器学习感兴趣? 赶紧来啊！\n也来说说你用哪些框架搭过 web 服务器？ express, koa, hapi ?我们希望你是搭在云上，比如阿里云，亚马逊，DigitalOcean, Heroku, Linode\n代码要舒服，测试要到位(TDD 你造吗？），有线上部署经验加分哦\n喜欢挑战和团队工作（放心，我们都很优秀），会尝试结对编程（结对，你懂的）\n全程参与到项目中，从创意，需求到开发，交付\n喜欢敏捷开发和迭代的模式，天下武功，唯快不破\n代码写的漂亮（空格还是 tab, 分号结尾要不要，欢迎来辩），产品要做就做到极致</p>\n<p>我们的福利\n人手 Macbook Pro\n六险一金，每月交通补贴，每年健身补贴\n还 5 天制，还有弹性时间😄 每月一天带薪病假，一天在家办公，\n更包午餐和晚餐，每月生日 party+ team outing\n更更赞助你参加技术会议</p>\n<p>招聘流程：\n简历初选（提供 github/开源项目妥妥哒）\n网上技术测试（过了测试离 offer 很近了）\n现场 /视频面试（中文 /英语面试）\nOFFER</p>\n<p>公司地址：广州市天河区花城大道 68 号环球都会大厦 1501\n公司网址：<a href=\"http://www.implus.co\">www.implus.co</a>\n邮箱地址: <a href=\"mailto:michelle.huang@implustech.com\">michelle.huang@implustech.com</a>\n更多图片请看楼主其他帖子😄</p>\n</div>",
            "title": "【广州】【招聘】听说你想要flexible的环境，工程师文化的团队，想要在家办公😄",
            "last_reply_at": "2017-05-26T00:39:37.012Z",
            "good": false,
            "top": false,
            "reply_count": 3,
            "visit_count": 62,
            "create_at": "2017-05-25T12:01:07.749Z",
            "author": {
                "loginname": "winging1991",
                "avatar_url": "https://avatars3.githubusercontent.com/u/22911161?v=3&s=120"
            }
        },
        {
            "id": "592725609e32cc84569a739e",
            "author_id": "58d4e6156f8b9bf02d1d0a92",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>请教各位前辈，我大二，总是听不进老师讲的，讲得感觉不够深入，很多知识都是自己看书理解的比较快，但是教材又比较薄讲得比较浅，有什么方法去学习操作系统原理？或者有什么书推荐？谢谢！</p>\n<p>来自酷炫的 <a href=\"https://github.com/TakWolf/CNode-Material-Design\">CNodeMD</a></p>\n</div>",
            "title": "请问怎样学习操作系统原理？",
            "last_reply_at": "2017-05-26T00:39:36.408Z",
            "good": false,
            "top": false,
            "reply_count": 1,
            "visit_count": 78,
            "create_at": "2017-05-25T18:41:36.019Z",
            "author": {
                "loginname": "q86002618",
                "avatar_url": "https://avatars0.githubusercontent.com/u/23697209?v=3&s=120"
            }
        }
    ]
}