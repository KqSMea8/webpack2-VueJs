
#### require.ensure

```
// 同步加载：var moment = require('moment'); console.log(moment().format());
// 按需加载（异步）模块，加载中生成异步文件，其路径是与index.tml同目录的
// 给require.ensure传递第三个参数，可以在output.chunkFilename中的[name]接收
// moment.js会被打包成一个单独的chunk文件，未被列在entry中，却又需要被打包出来的文件命名配置。
// []不为空 预加载懒执行
// webpack解惑：require的五种用法
// http://www.cnblogs.com/laneyfu/p/6158715.html

// require.ensure 是 Webpack 的特殊语法，用来设置 code-split point
// see https://webpack.js.org/guides/code-splitting-async/#require-ensure-

function determineDate () {
  require.ensure([], function (require) {
    var moment = require('moment/moment.js')
    console.log(moment().format())
  }, 'moment')
}

// vue 异步组件 
// 工厂函数接收一个 resolve 回调
// see https://cn.vuejs.org/v2/guide/components.html#异步组件

Vue.component('async-example', function (resolve, reject) {
  setTimeout(function () {
    // Pass the component definition to the resolve callback
    resolve({
      template: '<div>I am async!</div>'
    })
  }, 1000)
})

// 路由懒加载
// see https://router.vuejs.org/zh-cn/advanced/lazy-loading.html

const Foo = resolve => {
  // require.ensure 是 Webpack 的特殊语法，用来设置 code-split point
  // （代码分块）
  require.ensure(['./Foo.vue'], () => {
    resolve(require('./Foo.vue'))
  })
}

```

#### Vue
```
// Vue 插件 https://cn.vuejs.org/v2/guide/plugins.html

Getters

// 可以认为是 store 的计算属性
// 数据过滤处理，保留isdeleted为false 的数据
// 注意：根 store 子模块 news 内的 getters 初始化比子组件 news.vue为 news.newsList 给予填充后台数据要早，所以要先判断源 state.newsList 不为空，方可过滤处理
const getters = {
  getNews (state, getters, rootState) {
    if (state.newsList) {
      return state.newsList.filter(news => {
        return !news.isdelected
      })
    }
  }
}

Actions

const actions = {
  // Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。
  // 正因为 context 是对象，所以可以用对象的解构赋值，函数内的 commit = context.commit
  agree ({ state, commit, rootState }, newsid) {
    // 基于全局Vue对象使用http
    Vue.http.post('./php/agree.php', { newsid: newsid }, { emulateJSON: true }).then(function (res) {
      // 唤醒mutations中的setAgree方法，将从后台获取到的点赞数更新到Store.state
      commit(type.setAgree, res.body.agree)
    }, function (error) {
      console.log(error)
    })
  }
}

Mutations

// 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation
// 不能直接调用一个 mutation.handler()，通过 commit 来调用
// 每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方
const mutations = {
  // agreeNum为mutation的载荷（Payload）
  // 在大多数情况下，载荷应该是一个对象
  [type.setAgree] (state, agreeNum) {
    state.newsDetl.agree += agreeNum
  }
}

// unknown getter 已解决，注意引入方式，引入的应该是对象

移动端touch事件和click事件的区别
- 在移动端，手指点击一个元素，会经过：touchstart --> touchmove -> touchend --> click
- http://blog.csdn.net/lululove19870526/article/details/44345759

vm.$emit( event, […args] )触发当前实例上的事件，附加参数都会传给监听器回调。this.$emit('searchshow')，触发组件参数中注册的事件

```
v-if-vs-v-show 的区别

```
v-if 是“真正的”条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。
v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。
相比之下， v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。
一般来说， v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。
因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件不太可能改变，则使用 v-if 较好。
```

